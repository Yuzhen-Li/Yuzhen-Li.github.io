<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恩泽の博客</title>
  <icon>https://www.gravatar.com/avatar/366ef683e1866ae1c05b20ceb4ff7fd9</icon>
  <subtitle>有信、有望、有爱。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuzhen-li.github.io/"/>
  <updated>2018-05-13T09:15:30.084Z</updated>
  <id>https://yuzhen-li.github.io/</id>
  
  <author>
    <name>李恩泽(Enze_Li)</name>
    <email>liyuzhen@cmbchina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Python从零开始创建区块链</title>
    <link href="https://yuzhen-li.github.io/2018/05/13/%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://yuzhen-li.github.io/2018/05/13/用Python从零开始创建区块链/</id>
    <published>2018-05-13T09:07:53.000Z</published>
    <updated>2018-05-13T09:15:30.084Z</updated>
    
    <content type="html"><![CDATA[<p>作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。如果你还不是很了解哈希，可以百度相关知识。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>环境准备，确保已经安装Python3.6+, pip , Flask, requests<br>安装方法：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask==<span class="number">0.12</span><span class="number">.2</span> requests==<span class="number">2.18</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p><p>同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端.</p><p>请参考<a href="https://github.com/xilibi2003/blockchain.git" target="_blank" rel="noopener">源代码</a></p><h2 id="开始创建Blockchain"><a href="#开始创建Blockchain" class="headerlink" title="开始创建Blockchain"></a>开始创建Blockchain</h2><p>新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考<a href="https://github.com/xilibi2003/blockchain.git" target="_blank" rel="noopener">源代码</a></p><h3 id="Blockchain类"><a href="#Blockchain类" class="headerlink" title="Blockchain类"></a>Blockchain类</h3><p>首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。</p><p>以下是Blockchain类的框架：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.chain = []</span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Creates a new Block and adds it to the chain</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Adds a new transaction to the list of transactions</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod #声明了一个静态方法，不用实例化就可以调用该方法，可以直接类名调用方法，当然也可以实例化后再调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(block)</span>:</span></span><br><span class="line">        <span class="comment"># Hashes a Block</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property </span></span><br><span class="line"><span class="comment">#@property使方法像属性一样调用，就像是一种特殊的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Returns the last Block in the chain</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。</p><h2 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h2><p>每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。</p><p>以下是一个区块的结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">block = &#123;</span><br><span class="line">    <span class="string">'index'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'timestamp'</span>: <span class="number">1506057125.900785</span>,</span><br><span class="line">    <span class="string">'transactions'</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'sender'</span>: <span class="string">"8527147fe1f5426f9dd545de4b27ee00"</span>,</span><br><span class="line">            <span class="string">'recipient'</span>: <span class="string">"a77f5cdfa2934df3954a5c7c7da5df1f"</span>,</span><br><span class="line">            <span class="string">'amount'</span>: <span class="number">5</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'proof'</span>: <span class="number">324984774000</span>,</span><br><span class="line">    <span class="string">'previous_hash'</span>: <span class="string">"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化.</p><h2 id="加入交易"><a href="#加入交易" class="headerlink" title="加入交易"></a>加入交易</h2><p>接下来我们需要添加一个交易，来完善下new_transaction方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">(self, sender, recipient, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成新交易信息，信息将加入到下一个待挖的区块中</span></span><br><span class="line"><span class="string">        :param sender: &lt;str&gt; Address of the Sender</span></span><br><span class="line"><span class="string">        :param recipient: &lt;str&gt; Address of the Recipient</span></span><br><span class="line"><span class="string">        :param amount: &lt;int&gt; Amount</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            <span class="string">'sender'</span>: sender,</span><br><span class="line">            <span class="string">'recipient'</span>: recipient,</span><br><span class="line">            <span class="string">'amount'</span>: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_block[<span class="string">'index'</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。</p><h2 id="创建新块"><a href="#创建新块" class="headerlink" title="创建新块"></a>创建新块</h2><p>当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。</p><p>为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        self.chain = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create the genesis block 创世块</span></span><br><span class="line">        self.new_block(previous_hash=<span class="number">1</span>, proof=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_block</span><span class="params">(self, proof, previous_hash=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成新块</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm</span></span><br><span class="line"><span class="string">        :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block</span></span><br><span class="line"><span class="string">        :return: &lt;dict&gt; New Block</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">'index'</span>: len(self.chain) + <span class="number">1</span>,</span><br><span class="line">            <span class="string">'timestamp'</span>: time(),</span><br><span class="line">            <span class="string">'transactions'</span>: self.current_transactions,</span><br><span class="line">            <span class="string">'proof'</span>: proof,</span><br><span class="line">            <span class="string">'previous_hash'</span>: previous_hash <span class="keyword">or</span> self.hash(self.chain[<span class="number">-1</span>]),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset the current list of transactions</span></span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">        self.chain.append(block)</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">(self, sender, recipient, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成新交易信息，信息将加入到下一个待挖的区块中</span></span><br><span class="line"><span class="string">        :param sender: &lt;str&gt; Address of the Sender</span></span><br><span class="line"><span class="string">        :param recipient: &lt;str&gt; Address of the Recipient</span></span><br><span class="line"><span class="string">        :param amount: &lt;int&gt; Amount</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            <span class="string">'sender'</span>: sender,</span><br><span class="line">            <span class="string">'recipient'</span>: recipient,</span><br><span class="line">            <span class="string">'amount'</span>: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_block[<span class="string">'index'</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.chain[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(block)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成块的 SHA-256 hash值</span></span><br><span class="line"><span class="string">        :param block: &lt;dict&gt; Block</span></span><br><span class="line"><span class="string">        :return: &lt;str&gt;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes</span></span><br><span class="line">        block_string = json.dumps(block, sort_keys=<span class="keyword">True</span>).encode()</span><br><span class="line">        <span class="keyword">return</span> hashlib.sha256(block_string).hexdigest()</span><br></pre></td></tr></table></figure></p><p>通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。</p><h2 id="理解工作量证明"><a href="#理解工作量证明" class="headerlink" title="理解工作量证明"></a>理解工作量证明</h2><p>新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。</p><p>为了方便理解，举个例子：</p><p>假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？</p><p>用Python实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">0</span>  <span class="comment"># y未知</span></span><br><span class="line"><span class="keyword">while</span> sha256(<span class="string">f'<span class="subst">&#123;x*y&#125;</span>'</span>.encode()).hexdigest()[<span class="number">-1</span>] != <span class="string">"0"</span>:</span><br><span class="line">    y += <span class="number">1</span></span><br><span class="line">print(<span class="string">f'The solution is y = <span class="subst">&#123;y&#125;</span>'</span>)</span><br></pre></td></tr></table></figure></p><p>结果是y=21. 因为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="number">5</span> * <span class="number">21</span>) = <span class="number">1253e9373</span>e..<span class="number">.5e3600155</span>e860</span><br></pre></td></tr></table></figure></p><p>在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。</p><h2 id="实现工作量证明"><a href="#实现工作量证明" class="headerlink" title="实现工作量证明"></a>实现工作量证明</h2><p>让我们来实现一个相似PoW算法，规则是：寻找一个数p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">(self, last_proof)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        简单的工作量证明:</span></span><br><span class="line"><span class="string">         - 查找一个 p' 使得 hash(pp') 以4个0开头</span></span><br><span class="line"><span class="string">         - p 是上一个块的证明,  p' 是当前的证明</span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt;</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        proof = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> self.valid_proof(last_proof, proof) <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">            proof += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proof</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid_proof</span><span class="params">(last_proof, proof)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        验证证明: 是否hash(last_proof, proof)以4个0开头?</span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt; Previous Proof</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; Current Proof</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if correct, False if not.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="string">f'<span class="subst">&#123;last_proof&#125;</span><span class="subst">&#123;proof&#125;</span>'</span>.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        <span class="keyword">return</span> guess_hash[:<span class="number">4</span>] == <span class="string">"0000"</span></span><br></pre></td></tr></table></figure></p><p>衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。</p><p>现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。</p><h2 id="Blockchain作为API接口"><a href="#Blockchain作为API接口" class="headerlink" title="Blockchain作为API接口"></a>Blockchain作为API接口</h2><p>我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。</p><p>我们将创建三个接口：</p><pre><code>/transactions/new 创建一个交易并添加到区块/mine 告诉服务器去挖掘新的区块/chain 返回整个区块链</code></pre><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate our Node</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a globally unique address for this node</span></span><br><span class="line">node_identifier = str(uuid4()).replace(<span class="string">'-'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate the Blockchain</span></span><br><span class="line">blockchain = Blockchain()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/mine', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"We'll mine a new Block"</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.route('/transactions/new', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"We'll add a new transaction"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/chain', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_chain</span><span class="params">()</span>:</span></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'chain'</span>: blockchain.chain,</span><br><span class="line">        <span class="string">'length'</span>: len(blockchain.chain),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure></p><h2 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h2><p>发送到节点的交易数据结构如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"sender"</span>: <span class="string">"my address"</span>,</span><br><span class="line"> <span class="string">"recipient"</span>: <span class="string">"someone else's address"</span>,</span><br><span class="line"> <span class="string">"amount"</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之前已经有添加交易的方法，基于接口来添加交易就很简单了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/transactions/new', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">()</span>:</span></span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check that the required fields are in the POST'ed data</span></span><br><span class="line">    required = [<span class="string">'sender'</span>, <span class="string">'recipient'</span>, <span class="string">'amount'</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> all(k <span class="keyword">in</span> values <span class="keyword">for</span> k <span class="keyword">in</span> required):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Missing values'</span>, <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a new Transaction</span></span><br><span class="line">    index = blockchain.new_transaction(values[<span class="string">'sender'</span>], values[<span class="string">'recipient'</span>], values[<span class="string">'amount'</span>])</span><br><span class="line"></span><br><span class="line">    response = &#123;<span class="string">'message'</span>: <span class="string">f'Transaction will be added to Block <span class="subst">&#123;index&#125;</span>'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">201</span></span><br></pre></td></tr></table></figure></p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>挖矿正是神奇所在，它很简单，做了一下三件事：</p><ul><li>计算工作量证明PoW</li><li>通过新增一个交易授予矿工（自己）一个币</li><li>构造新区块并将其添加到链中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4<span class="comment">#128位的全局唯一标识符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/mine', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># We run the proof of work algorithm to get the next proof...</span></span><br><span class="line">    last_block = blockchain.last_block</span><br><span class="line">    last_proof = last_block[<span class="string">'proof'</span>]</span><br><span class="line">    proof = blockchain.proof_of_work(last_proof)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给工作量证明的节点提供奖励.</span></span><br><span class="line">    <span class="comment"># 发送者为 "0" 表明是新挖出的币</span></span><br><span class="line">    blockchain.new_transaction(</span><br><span class="line">        sender=<span class="string">"0"</span>,</span><br><span class="line">        recipient=node_identifier,</span><br><span class="line">        amount=<span class="number">1</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forge the new Block by adding it to the chain</span></span><br><span class="line">    block = blockchain.new_block(proof)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'message'</span>: <span class="string">"New Block Forged"</span>,</span><br><span class="line">        <span class="string">'index'</span>: block[<span class="string">'index'</span>],</span><br><span class="line">        <span class="string">'transactions'</span>: block[<span class="string">'transactions'</span>],</span><br><span class="line">        <span class="string">'proof'</span>: block[<span class="string">'proof'</span>],</span><br><span class="line">        <span class="string">'previous_hash'</span>: block[<span class="string">'previous_hash'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br></pre></td></tr></table></figure></li></ul><p>注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下</p><h2 id="运行区块链"><a href="#运行区块链" class="headerlink" title="运行区块链"></a>运行区块链</h2><p>你可以使用cURL 或Postman 去和API进行交互</p><p>启动server:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python blockchain.py</span><br><span class="line">* Runing on http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure></p><p>让我们通过请求 <a href="http://localhost:5000/mine" target="_blank" rel="noopener">http://localhost:5000/mine</a> 来进行挖矿<br><img src="http://img.blog.csdn.net/20171031131356486?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlsaWJpMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片"><br>通过post请求，添加一个新交易<br><img src="http://img.blog.csdn.net/20171031131451383?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlsaWJpMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片"><br>如果不是使用Postman，则用一下的cURL语句也是一样的：<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H <span class="string">"Content-Type: application/json"</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string"> "</span>sender<span class="string">": "</span>d4ee26eee15148ee92c6cd394edd974e<span class="string">",</span></span><br><span class="line"><span class="string"> "</span>recipient<span class="string">": "</span>someone-other-address<span class="string">",</span></span><br><span class="line"><span class="string"> "</span>amount<span class="string">": 5</span></span><br><span class="line"><span class="string">&#125;'</span> <span class="string">"http://localhost:5000/transactions/new"</span></span><br></pre></td></tr></table></figure></p><p>在挖了两次矿之后，就有3个块了，通过请求 <a href="http://localhost:5000/chain" target="_blank" rel="noopener">http://localhost:5000/chain</a> 可以得到所有的块信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"chain"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"index"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"previous_hash"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"proof"</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="number">1506280650.770839</span>,</span><br><span class="line">      <span class="string">"transactions"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"index"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"previous_hash"</span>: <span class="string">"c099bc...bfb7"</span>,</span><br><span class="line">      <span class="string">"proof"</span>: <span class="number">35293</span>,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="number">1506280664.717925</span>,</span><br><span class="line">      <span class="string">"transactions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"amount"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"recipient"</span>: <span class="string">"8bbcb347e0634905b0cac7955bae152b"</span>,</span><br><span class="line">          <span class="string">"sender"</span>: <span class="string">"0"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"index"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">"previous_hash"</span>: <span class="string">"eff91a...10f2"</span>,</span><br><span class="line">      <span class="string">"proof"</span>: <span class="number">35089</span>,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="number">1506280666.1086972</span>,</span><br><span class="line">      <span class="string">"transactions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"amount"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"recipient"</span>: <span class="string">"8bbcb347e0634905b0cac7955bae152b"</span>,</span><br><span class="line">          <span class="string">"sender"</span>: <span class="string">"0"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"length"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一致性（共识）"><a href="#一致性（共识）" class="headerlink" title="一致性（共识）"></a>一致性（共识）</h2><p>我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。</p><h3 id="注册节点"><a href="#注册节点" class="headerlink" title="注册节点"></a>注册节点</h3><p>在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口：</p><ol><li>/nodes/register 接收URL形式的新节点列表</li><li>/nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链</li></ol><p>我们修改下Blockchain的init函数并提供一个注册节点方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self.nodes = set()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_node</span><span class="params">(self, address)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a new node to the list of nodes</span></span><br><span class="line"><span class="string">        :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000'</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        parsed_url = urlparse(address)<span class="comment">#用于解析url中的参数  对url按照一定格式进行 拆分或拼接</span></span><br><span class="line">        self.nodes.add(parsed_url.netloc)<span class="comment">#netloc 是域名服务器</span></span><br></pre></td></tr></table></figure></p><p>我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。</p><h3 id="实现共识算法"><a href="#实现共识算法" class="headerlink" title="实现共识算法"></a>实现共识算法</h3><p>前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。</p><p>我们使用以下的算法，来达到网络中的共识<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">valid_chain</span><span class="params">(self, chain)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Determine if a given blockchain is valid</span></span><br><span class="line"><span class="string">        :param chain: &lt;list&gt; A blockchain</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if valid, False if not</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        last_block = chain[<span class="number">0</span>]</span><br><span class="line">        current_index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current_index &lt; len(chain):</span><br><span class="line">            block = chain[current_index]</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;last_block&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;block&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">"\n-----------\n"</span>)</span><br><span class="line">            <span class="comment"># Check that the hash of the block is correct</span></span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">'previous_hash'</span>] != self.hash(last_block):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check that the Proof of Work is correct</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.valid_proof(last_block[<span class="string">'proof'</span>], block[<span class="string">'proof'</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            last_block = block</span><br><span class="line">            current_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolve_conflicts</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        共识算法解决冲突</span></span><br><span class="line"><span class="string">        使用网络中最长的链.</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True 如果链被取代, 否则为False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        neighbours = self.nodes</span><br><span class="line">        new_chain = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We're only looking for chains longer than ours</span></span><br><span class="line">        max_length = len(self.chain)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Grab and verify the chains from all the nodes in our network</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> neighbours:</span><br><span class="line">            response = requests.get(<span class="string">f'http://<span class="subst">&#123;node&#125;</span>/chain'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                length = response.json()[<span class="string">'length'</span>]</span><br><span class="line">                chain = response.json()[<span class="string">'chain'</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check if the length is longer and the chain is valid</span></span><br><span class="line">                <span class="keyword">if</span> length &gt; max_length <span class="keyword">and</span> self.valid_chain(chain):</span><br><span class="line">                    max_length = length</span><br><span class="line">                    new_chain = chain</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Replace our chain if we discovered a new, valid chain longer than ours</span></span><br><span class="line">        <span class="keyword">if</span> new_chain:</span><br><span class="line">            self.chain = new_chain</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof.</p><p>第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链;就是比较每个节点（服务器）上的最长有效链。<br>让我们添加两个路由，一个用来注册节点，一个用来解决冲突。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/nodes/register', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_nodes</span><span class="params">()</span>:</span></span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    nodes = values.get(<span class="string">'nodes'</span>)</span><br><span class="line">    <span class="keyword">if</span> nodes <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Error: Please supply a valid list of nodes"</span>, <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        blockchain.register_node(node)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'message'</span>: <span class="string">'New nodes have been added'</span>,</span><br><span class="line">        <span class="string">'total_nodes'</span>: list(blockchain.nodes),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/nodes/resolve', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consensus</span><span class="params">()</span>:</span></span><br><span class="line">    replaced = blockchain.resolve_conflicts()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> replaced:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'message'</span>: <span class="string">'Our chain was replaced'</span>,</span><br><span class="line">            <span class="string">'new_chain'</span>: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'message'</span>: <span class="string">'Our chain is authoritative'</span>,</span><br><span class="line">            <span class="string">'chain'</span>: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br></pre></td></tr></table></figure></p><p>你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：<a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> 和 <a href="http://localhost:5001" target="_blank" rel="noopener">http://localhost:5001</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipenv run python blockchain.py</span><br><span class="line">pipenv run python blockchain.py -p <span class="number">5001</span></span><br></pre></td></tr></table></figure></p><p><img src="http://img.blog.csdn.net/20171031113409302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlsaWJpMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图"></p><p>然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。<br><img src="http://img.blog.csdn.net/20171031131545136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlsaWJpMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="tu"><br>好啦，你可以邀请朋友们一起来测试你的区块链!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="区块链" scheme="https://yuzhen-li.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Python" scheme="https://yuzhen-li.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器之@property</title>
    <link href="https://yuzhen-li.github.io/2018/05/10/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B9%8B@property/"/>
    <id>https://yuzhen-li.github.io/2018/05/10/Python装饰器之@property/</id>
    <published>2018-05-10T07:39:12.000Z</published>
    <updated>2018-05-10T07:42:24.302Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line">考察 Student 类：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">当我们想要修改一个 Student 的 scroe 属性时，可以这么写：</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line">但是也可以这么写：</span><br><span class="line"></span><br><span class="line">s.score = <span class="number">1000</span></span><br><span class="line">显然，直接给属性赋值无法检查分数的有效性。</span><br><span class="line"></span><br><span class="line">如果利用两个方法：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        self.__score = score</span><br><span class="line">这样一来，s.set_score(<span class="number">1000</span>) 就会报错。</span><br><span class="line"></span><br><span class="line">这种使用 get/set 方法来封装对一个属性的访问在许多面向对象编程的语言中都很常见。</span><br><span class="line"></span><br><span class="line">但是写 s.get_score() 和 s.set_score() 没有直接写 s.score 来得直接。</span><br><span class="line"></span><br><span class="line">有没有两全其美的方法？----有。</span><br><span class="line"></span><br><span class="line">因为Python支持高阶函数，在函数式编程中我们介绍了装饰器函数，可以用装饰器函数把 get/set 方法“装饰”成属性调用：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        self.__score = score</span><br><span class="line">注意: 第一个score(self)是get方法，用@property装饰，第二个score(self, score)是set方法，用@score.setter装饰，@score.setter是前一个@property装饰后的副产品。</span><br><span class="line"></span><br><span class="line">现在，就可以像使用属性一样设置score了：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s.score</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">1000</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: invalid score</span><br><span class="line">说明对 score 赋值实际调用的是 set方法。</span><br><span class="line"></span><br><span class="line">任务</span><br><span class="line">如果没有定义set方法，就不能对“属性”赋值，这时，就可以创建一个只读“属性”。</span><br><span class="line"></span><br><span class="line">请给Student类加一个grade属性，根据 score 计算 A（&gt;=<span class="number">80</span>）、B、C（&lt;<span class="number">60</span>）。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="python" scheme="https://yuzhen-li.github.io/tags/python/"/>
    
      <category term="property" scheme="https://yuzhen-li.github.io/tags/property/"/>
    
      <category term="装饰器" scheme="https://yuzhen-li.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>这是一个测试</title>
    <link href="https://yuzhen-li.github.io/2018/04/17/test/"/>
    <id>https://yuzhen-li.github.io/2018/04/17/test/</id>
    <published>2018-04-17T09:56:11.000Z</published>
    <updated>2018-04-17T10:04:16.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试"><a href="#这是一个测试" class="headerlink" title="这是一个测试"></a>这是一个测试</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil, floor, log</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count  <span class="comment"># combinations, count, product</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">from</span> mapper.tools <span class="keyword">import</span> qhull, shortest_path, pdfwriter, graphviz_node_pos, dict_values</span><br><span class="line"></span><br><span class="line">mplversion = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> mpl.__version__.split(<span class="string">' '</span>)[<span class="number">0</span>].split(<span class="string">'.'</span>)[:<span class="number">2</span>]]</span><br><span class="line"><span class="keyword">if</span> mplversion &lt; [<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Warning: Best results are obtained with Matplotlib version at '</span></span><br><span class="line">           <span class="string">'least 1.0.\n'</span></span><br><span class="line">           <span class="string">'Python Mapper should work with Matplotlib 0.99, too, but some '</span></span><br><span class="line">           <span class="string">'features are\nmissing.'</span>)</span><br><span class="line"><span class="keyword">if</span> mplversion &lt; [<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">    <span class="comment"># Specification for a short horizontal line, 'hline'.</span></span><br><span class="line">    <span class="comment"># We cannot use the first specification universally since Matplotlib</span></span><br><span class="line">    <span class="comment"># changed the angle parameter from radians to degree in 1.1.0.</span></span><br><span class="line">    hlinemarkersymbol = (<span class="number">2</span>, <span class="number">2</span>, <span class="number">.5</span> * np.pi)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># (2,2,90) does work, too, but Matplotlib 1.1.0 knows the symbol '_'.</span></span><br><span class="line">    hlinemarkersymbol = <span class="string">'_'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这是一个测试&quot;&gt;&lt;a href=&quot;#这是一个测试&quot; class=&quot;headerlink&quot; title=&quot;这是一个测试&quot;&gt;&lt;/a&gt;这是一个测试&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="test" scheme="https://yuzhen-li.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>docker（一）</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/docker%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/docker（一）/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-05-10T07:50:45.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装docker-for-ubuntu"><a href="#安装docker-for-ubuntu" class="headerlink" title="安装docker for ubuntu"></a>安装docker for ubuntu</h2><p>从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="comment">[选项]</span> <span class="comment">[Docker Registry 地址<span class="comment">[:端口号]</span>/]</span>仓库名<span class="comment">[:标签]</span></span><br></pre></td></tr></table></figure></p><p>具体的选项可以通过 docker pull –help 命令看到,这里我们说一下镜像 名 称 的 格 式。Docker 镜像仓库地址：地址的格式一般是&lt;域名/IP&gt;[:端口号]。默认地址是Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。 对于 DockerHub，如果不给出用户名，则默认为librar，也就是官方镜像。<br>比如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull <span class="string">ubuntu:</span><span class="number">16.04</span></span><br><span class="line"><span class="number">16.04</span>: Pulling from library/ubuntu</span><br><span class="line"><span class="string">bf5d46315322:</span> Pull complete</span><br><span class="line"><span class="number">9</span><span class="string">f13e0ac480c:</span> Pull complete</span><br><span class="line"><span class="string">e8988b5b3097:</span> Pull complete</span><br><span class="line"><span class="number">40</span><span class="string">af181810e7:</span> Pull complete</span><br><span class="line"><span class="string">e6f7c7e5c03e:</span> Pull complete</span><br><span class="line"><span class="string">Digest:</span> <span class="string">sha256:</span><span class="number">147913621</span>d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span><span class="number">16.04</span></span><br></pre></td></tr></table></figure></p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 docker image ls或者docker images 命令。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              c9d990395902        <span class="number">2</span> weeks ago         <span class="number">113</span>MB</span><br><span class="line">cita/cita-run       latest              <span class="number">14</span>f6fa0d1610        <span class="number">3</span> weeks ago         <span class="number">530</span>MB</span><br><span class="line">cita/cita-build     latest              <span class="number">3</span>ea9fdb515e6        <span class="number">4</span> weeks ago         <span class="number">1.47</span>GB</span><br></pre></td></tr></table></figure><p>镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。</p><h2 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h2><p>你可以通过以下命令来便捷的查看<strong>镜像、容器、数据卷</strong>所占用的空间<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> system </span>df</span><br><span class="line">TYPE TOTAL ACTIVE SIZE RECLAI</span><br><span class="line">MABLE</span><br><span class="line">Images 24 0 1.992GB 1.992G</span><br><span class="line">B (100%)</span><br><span class="line">Containers 1 0 62.82MB 62.82M</span><br><span class="line">B (100%)</span><br><span class="line">Local Volumes 9 0 652.2MB 652.2M</span><br><span class="line">B (100%)</span><br><span class="line">Build Cache 0B 0</span><br></pre></td></tr></table></figure></p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm <span class="string">[选项]</span> &lt;镜像<span class="number">1</span>&gt; <span class="string">[&lt;镜像2&gt; ...]</span></span><br></pre></td></tr></table></figure><p>其中， &lt;镜像&gt; 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者镜像摘要。</p><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> = docker create + docker start</span></span><br></pre></td></tr></table></figure><h2 id="镜像定制"><a href="#镜像定制" class="headerlink" title="镜像定制"></a>镜像定制</h2><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">run</span> <span class="comment">--name webserver -d -p 80:80 nginx</span></span><br></pre></td></tr></table></figure></p><p>这条命令会用 nginx 镜像启动一个容器，命名为 webserver ，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost；如果使用的是" target="_blank" rel="noopener">http://localhost；如果使用的是</a> Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用docker exec 命令进入容器，修改其内容。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker exec -it webserver bash</span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># exit</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>我们以交互式终端方式进入webserver容器，并执行了bash命令，也就是获得一个可操作的 Shell。然后，我们用 </p><h1>Hello, Docker!</h1> 覆盖了 /usr/share/nginx/html/index.html的内容。现在我们再刷新浏览器的话，会发现内容被改变了.<p></p><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。<br>而 Docker 提供了一个docker commit命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; <span class="meta">[&lt;仓库名&gt;[:&lt;标签&gt;]</span>]</span><br></pre></td></tr></table></figure></p><p>我们可以用下面的命令将容器保存为镜像：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">-<span class="ruby">-author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</span></span><br><span class="line"><span class="ruby">--message <span class="string">"修改了默认网页"</span> \</span></span><br><span class="line"><span class="ruby">webserver \</span></span><br><span class="line"><span class="ruby"><span class="symbol">nginx:</span>v2</span></span><br><span class="line"><span class="ruby"><span class="symbol">sha256:</span><span class="number">07</span>e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span></span><br></pre></td></tr></table></figure></p><p>其中 –author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git<br>版本控制相似，不过这里这些信息可以省略留空。<br>我们可以在 docker image ls 中看到这个新定制的镜像.</p><h2 id="Dockerfile-镜像定制"><a href="#Dockerfile-镜像定制" class="headerlink" title="Dockerfile 镜像定制"></a>Dockerfile 镜像定制</h2><p>从刚才的 docker commit的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装docker-for-ubuntu&quot;&gt;&lt;a href=&quot;#安装docker-for-ubuntu&quot; class=&quot;headerlink&quot; title=&quot;安装docker for ubuntu&quot;&gt;&lt;/a&gt;安装docker for ubuntu&lt;/h2&gt;&lt;p&gt;从 
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="docker" scheme="https://yuzhen-li.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>NLP的JSON格式输出</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/NLP%E7%9A%84JSON%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/NLP的JSON格式输出/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-16T09:18:24.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分词的JSON格式输出"><a href="#分词的JSON格式输出" class="headerlink" title="分词的JSON格式输出"></a>分词的JSON格式输出</h1><h2 id="实现核心"><a href="#实现核心" class="headerlink" title="实现核心"></a>实现核心</h2><p>实现的核心是构造 convertToJson(words)函数，首先需要将各种策略下的分词输出，转化成list输出。保证输入该函数的参数是list。该函数的具体代码如下：<br><figure class="highlight ruby"><figcaption><span>python:objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertToJson</span><span class="params">(words)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment">#the paramter words have been already segmented</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#词性标注功能</span></span><br><span class="line">    postagger = Postagger()  </span><br><span class="line">    postagger.load(<span class="string">"/models/pyltp/ltp_data_v3.4.0/pos.model"</span>)  </span><br><span class="line">    postags = postagger.postag(words) </span><br><span class="line">    postagger.release()  <span class="comment"># 释放模型 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果整合为json。这是重点。我把原代码的print全部注释。  </span></span><br><span class="line">    resultJson=[] <span class="comment">#创建一个空列表，用于保存json数据。  </span></span><br><span class="line">    length = len(words)</span><br><span class="line">    <span class="keyword">begin</span>= []</span><br><span class="line">    <span class="keyword">end</span> = []</span><br><span class="line">    <span class="keyword">begin</span>.append(<span class="number">0</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="symbol">length:</span></span><br><span class="line">         <span class="keyword">end</span>.append(<span class="keyword">begin</span>[i] + len(words[i]) - <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">if</span> i == length - <span class="number">1</span><span class="symbol">:</span></span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">         <span class="symbol">else:</span></span><br><span class="line">             <span class="keyword">begin</span>.append(<span class="keyword">begin</span>[i] + len(words[i]))</span><br><span class="line">         i=i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(words))<span class="symbol">:</span><span class="comment">#遍历结果  </span></span><br><span class="line">        resultJson.append(&#123;<span class="string">'id'</span><span class="symbol">:index</span>,<span class="string">'begin'</span><span class="symbol">:begin</span>[index],<span class="string">'end'</span><span class="symbol">:end</span>[index],<span class="string">'cont'</span><span class="symbol">:words</span>[index],<span class="string">'pos'</span><span class="symbol">:postags</span>[index]&#125;) <span class="comment">#将各功能的结果对应地添加到json中  </span></span><br><span class="line">    <span class="keyword">return</span> resultJson <span class="comment"># 返回函数结果  </span></span><br></pre></td></tr></table></figure></p><p>这个函数中用pyltp库实现了词性标注，而且标注了每个分词在原来句子中的位置。<br>最后通过一个大循环把所有的结果存到resultJson，最后可以应用dumps函数实现json格式转换。</p><pre><code>result=json.dumps({&apos;status&apos;:&apos;0&apos;,&apos;inputStr&apos;:inputStr,&apos;mode&apos;:methodNum,&apos;outputStr&apos;:finalResult},ensure_ascii=False,indent=2)</code></pre><h2 id="遇到的问题和解决方案"><a href="#遇到的问题和解决方案" class="headerlink" title="遇到的问题和解决方案"></a>遇到的问题和解决方案</h2><p>   在与前端联调的过程中出现问题，总是不同，有500的错误提出。消耗了我两天多的时间，最后发现问题是：前端发给我的数字都是字符串，而我在后面代码中的数字都是int型的，所以出问题。最后的解决办法是，将前端发过来的数字强制转换成int型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分词的JSON格式输出&quot;&gt;&lt;a href=&quot;#分词的JSON格式输出&quot; class=&quot;headerlink&quot; title=&quot;分词的JSON格式输出&quot;&gt;&lt;/a&gt;分词的JSON格式输出&lt;/h1&gt;&lt;h2 id=&quot;实现核心&quot;&gt;&lt;a href=&quot;#实现核心&quot; class=&quot;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="分词" scheme="https://yuzhen-li.github.io/tags/%E5%88%86%E8%AF%8D/"/>
    
      <category term="JSON" scheme="https://yuzhen-li.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理textblog安装使用</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86textblog%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/自然语言处理textblog安装使用/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-15T16:09:52.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自然语言处理-textblog-安装使用"><a href="#自然语言处理-textblog-安装使用" class="headerlink" title="自然语言处理 textblog 安装使用"></a>自然语言处理 textblog 安装使用</h1><h2 id="TextBlob是什么？"><a href="#TextBlob是什么？" class="headerlink" title="TextBlob是什么？"></a>TextBlob是什么？</h2><p>TextBlob是一个用Python编写的开源的文本处理库。它可以用来执行很多自然语言处理的任务，比如，词性标注，名词性成分提取，情感分析，文本翻译，等等。你可以在官方文档阅读TextBlog的所有特性。</p><p>github 地址：<a href="https://github.com/sloria/TextBlob/" target="_blank" rel="noopener">https://github.com/sloria/TextBlob/</a></p><p>文档地址：<a href="https://textblob.readthedocs.io/en/dev/" target="_blank" rel="noopener">https://textblob.readthedocs.io/en/dev/</a><br>TextBlob是在NLTK和pattern基础上构建的，并且与这两者完美契合。</p><h2 id="安装-TextBlob"><a href="#安装-TextBlob" class="headerlink" title="安装 TextBlob"></a>安装 TextBlob</h2><pre><code>$ pip install -U textblob$ python -m textblob.download_corpora # 下载nltk数据包，如果已经在nltk 安装的时候下载好了nltk数据包，不需要此步骤</code></pre><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>Create a TextBlob（创建一个textblob对象）</p><pre><code>from textblob import TextBlobwiki = TextBlob(&quot;Python is a high-level, general-purpose programming language.&quot;)</code></pre><p>Part-of-speech Tagging（词性标注）</p><pre><code>wiki.tags[(&apos;Python&apos;, &apos;NNP&apos;), (&apos;is&apos;, &apos;VBZ&apos;), (&apos;a&apos;, &apos;DT&apos;), (&apos;high-level&apos;, &apos;JJ&apos;), (&apos;general-purpose&apos;, &apos;JJ&apos;), (&apos;programming&apos;, &apos;NN&apos;), (&apos;language&apos;, &apos;NN&apos;)]</code></pre><p>Sentiment Analysis（情感分析）</p><pre><code>testimonial = TextBlob(&quot;Textblob is amazingly simple to use. What great fun!&quot;)testimonial.sentimentSentiment(polarity=0.39166666666666666, subjectivity=0.4357142857142857)testimonial.sentiment.polarity0.39166666666666666</code></pre><p>Tokenization（分词和分句）</p><pre><code>zen = TextBlob(&quot;Beautiful is better than ugly. &quot;...                &quot;Explicit is better than implicit. &quot;...                &quot;Simple is better than complex.&quot;)zen.wordsWordList([&apos;Beautiful&apos;, &apos;is&apos;, &apos;better&apos;, &apos;than&apos;, &apos;ugly&apos;, &apos;Explicit&apos;, &apos;is&apos;, &apos;better&apos;, &apos;than&apos;, &apos;implicit&apos;, &apos;Simple&apos;, &apos;is&apos;, &apos;better&apos;, &apos;than&apos;, &apos;complex&apos;])zen.sentences[Sentence(&quot;Beautiful is better than ugly.&quot;), Sentence(&quot;Explicit is better than implicit.&quot;), Sentence(&quot;Simple is better than complex.&quot;)]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自然语言处理-textblog-安装使用&quot;&gt;&lt;a href=&quot;#自然语言处理-textblog-安装使用&quot; class=&quot;headerlink&quot; title=&quot;自然语言处理 textblog 安装使用&quot;&gt;&lt;/a&gt;自然语言处理 textblog 安装使用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="textblog" scheme="https://yuzhen-li.github.io/tags/textblog/"/>
    
  </entry>
  
  <entry>
    <title>NLP处理之polyglot</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/NLP%E5%A4%84%E7%90%86%E4%B9%8Bpolyglot/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/NLP处理之polyglot/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-16T08:33:53.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install polyglot</span></span><br></pre></td></tr></table></figure><p>安装依赖库</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install python-numpy libicu-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>在Python中import _icu（这个语句其实在polyglot安装成功后import polyglot.text是报错发现的）的时候，发现importerror …. _icu.so: no defined …(忘了)<br>所以我们这个动态链接库是没有build成功的。<br>可能是pip install的时候没有生成一个好的_icu.so<br>所以我们要在安装python模块的时候入手，icu4c模块应该没问题了。<br>编译安装成功<br>我就不用pip安装了，直接下源码</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://pypi.python.org/packages/bf/<span class="number">1</span>f/cea<span class="number">237</span>f<span class="number">542e3</span>bb<span class="number">592980008</span>a<span class="number">734850e8</span>cbbc<span class="number">25</span><span class="keyword">c</span><span class="number">19</span><span class="keyword">c</span><span class="number">72</span><span class="keyword">c</span><span class="number">98767</span><span class="keyword">c</span><span class="number">71</span><span class="keyword">c</span><span class="number">1</span>bd<span class="number">9</span><span class="keyword">c</span><span class="number">2</span>/PyICU<span class="number">-2.0</span>.<span class="number">3</span>.tar.gz</span><br><span class="line"># (去官网下载，我的是<span class="number">1.9</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">tar zxvf PyICU<span class="number">-2.0</span>.<span class="number">3</span>.tar.gz</span><br><span class="line">cd PyICU<span class="number">-2.0</span>.<span class="number">3</span>.tar.gz</span><br></pre></td></tr></table></figure><p>此时如果你是linux系统要修改一下setup.py文件<br>具体如下图所示</p><p><img src="/assets/blogImg/test1.jpg" alt="图1"><br><img src="/assets/blogImg/test2.jpg" alt="图2"></p><p>然后</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup<span class="selector-class">.py</span> build</span><br><span class="line">sudo python setup<span class="selector-class">.py</span> install</span><br></pre></td></tr></table></figure><h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from polyglot.text <span class="keyword">import</span> <span class="built_in">Text</span></span><br><span class="line"></span><br><span class="line">blob = <span class="string">u"""The baby eagle liked the nest. It was the only world he had ever known. It was warm and comfortable, had a great view, and even better, he had all the food and love and attention that a great mother eagle could provide"""</span></span><br><span class="line"></span><br><span class="line">text = <span class="built_in">Text</span>(blob)</span><br><span class="line"></span><br><span class="line">text.words</span><br></pre></td></tr></table></figure><h1 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h1><p>首先需要下载通用词性标签集</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">polyglot</span> <span class="selector-tag">download</span> <span class="selector-tag">embeddings2</span><span class="selector-class">.en</span> <span class="selector-tag">pos2</span><span class="selector-class">.en</span></span><br></pre></td></tr></table></figure><p>这一步要等好久好久，反正我等得是花都谢了，N次怀疑电脑卡死了。<br>词性标注具体代码如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from polyglot.text <span class="keyword">import</span> <span class="built_in">Text</span></span><br><span class="line"></span><br><span class="line">blob = <span class="string">"""We will meet at eight o'clock on Thursday morning."""</span></span><br><span class="line">text = <span class="built_in">Text</span>(blob)</span><br><span class="line"></span><br><span class="line">text.pos_tags</span><br></pre></td></tr></table></figure><h1 id="实体识别"><a href="#实体识别" class="headerlink" title="实体识别"></a>实体识别</h1><p>首先也要安装相关依赖包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">polyglot</span> <span class="selector-tag">download</span> <span class="selector-tag">embeddings2</span><span class="selector-class">.en</span> <span class="selector-tag">ner2</span><span class="selector-class">.en</span></span><br></pre></td></tr></table></figure><p>相关代码如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from polyglot.text <span class="keyword">import</span> <span class="built_in">Text</span></span><br><span class="line">blob = <span class="string">"""The Israeli Prime Minister Benjamin Netanyahu has warned that Iran poses a "threat to the entire world"."""</span></span><br><span class="line">text = <span class="built_in">Text</span>(blob)</span><br><span class="line"></span><br><span class="line">text.entities</span><br></pre></td></tr></table></figure><p>但是上面打印出来的结果不是字典的形式，为了最后成为字典，可以这样处理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nerL = [ ]</span><br><span class="line">nerR = &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> sent int text<span class="selector-class">.sentences</span>:</span><br><span class="line">    <span class="keyword">for</span> entity <span class="keyword">in</span> sent<span class="selector-class">.entities</span>:</span><br><span class="line">        nerL.append(entity)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter <span class="keyword">in</span> nerL:</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> iter:</span><br><span class="line">        nerR[i] = iter.tag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(R)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="polyglot" scheme="https://yuzhen-li.github.io/tags/polyglot/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理之spacy库</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%B9%8Bspacy%E5%BA%93/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/自然语言处理之spacy库/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-15T16:07:36.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Python-spaCy-进行简易自然语言处理"><a href="#使用-Python-spaCy-进行简易自然语言处理" class="headerlink" title="使用 Python+spaCy 进行简易自然语言处理"></a>使用 Python+spaCy 进行简易自然语言处理</h1><h2 id="spaCy-简介及安装方法"><a href="#spaCy-简介及安装方法" class="headerlink" title="spaCy 简介及安装方法"></a>spaCy 简介及安装方法</h2><p>安装和编译 spaCy 比较方便，在ubuntu环境下，直接用pip安装即可：</p><pre><code>sudo apt-get install build-essential python-dev gitsudo pip install -U spacy</code></pre><p>不过安装完毕之后，需要下载相关的模型数据，以英文模型数据为例，可以用”all”参数下载所有的数据:</p><pre><code>sudo python -m spacy.en.download all</code></pre><p>可能提示 no module named spacy.en</p><p>则执行：python -m spacy download en 即可</p><p>现在可以快速测试一下spaCy的相关功能，我们以英文数据为例，spaCy目前主要支持英文和德文，对其他语言的支持正在陆续加入：</p><pre><code># 加载英文模型数据，稍许等待In [2]: nlp = spacy.load(&apos;en&apos;)</code></pre><h2 id="分词："><a href="#分词：" class="headerlink" title="分词："></a>分词：</h2><pre><code>In [3]: test_doc = nlp(u&quot;it&apos;s word tokenize test for spacy&quot;)In [4]: print(test_doc)it&apos;s word tokenize test for spacyIn [5]: for token in test_doc:print(token)...:it&apos;swordtokenizetestforspacy英文断句:In [6]: test_doc = nlp(u&apos;Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.&apos;)In [7]: for sent in test_doc.sents:print(sent)...:Natural language processing (NLP) deals with the application of computational models to text or speech data.Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways.NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form.From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.</code></pre><h2 id="词性标注-POS-Tagging"><a href="#词性标注-POS-Tagging" class="headerlink" title="词性标注(POS Tagging):"></a>词性标注(POS Tagging):</h2><pre><code>In [10]: for token in test_doc:print(token, token.pos_, token.pos)....:(you, u&apos;PRON&apos;, 92)(are, u&apos;VERB&apos;, 97)(best, u&apos;ADJ&apos;, 82)(., u&apos;PUNCT&apos;, 94)(it, u&apos;PRON&apos;, 92)(is, u&apos;VERB&apos;, 97)(lemmatize, u&apos;ADJ&apos;, 82)(test, u&apos;NOUN&apos;, 89)(for, u&apos;ADP&apos;, 83)(spacy, u&apos;NOUN&apos;, 89)(., u&apos;PUNCT&apos;, 94)(I, u&apos;PRON&apos;, 92)(love, u&apos;VERB&apos;, 97)(these, u&apos;DET&apos;, 87)(books, u&apos;NOUN&apos;, 89)</code></pre><h2 id="命名实体识别（NER）："><a href="#命名实体识别（NER）：" class="headerlink" title="命名实体识别（NER）："></a>命名实体识别（NER）：</h2><pre><code>In [11]: test_doc = nlp(u&quot;Rami Eid is studying at Stony Brook University in New York&quot;)In [12]: for ent in test_doc.ents:print(ent, ent.label_, ent.label)....:(Rami Eid, u&apos;PERSON&apos;, 346)(Stony Brook University, u&apos;ORG&apos;, 349)(New York, u&apos;GPE&apos;, 350)</code></pre><p>代码统一整理：</p><pre><code>import spacynlp = spacy.load(&apos;en&apos;)test_doc = nlp(u&quot;it&apos;s word tokenize test for spacy&quot;)# 分词print(&quot;\n1、分词&quot;)print(test_doc)for token in test_doc:    print(token)# 分句print(&quot;\n2、分句&quot;)test_doc = nlp(u&apos;Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.&apos;)print(test_doc)for sent in test_doc.sents:    print(sent)# 词干化print(&quot;\n3、词干化&quot;)test_doc = nlp(u&quot;you are best. it is lemmatize test for spacy. I love these books&quot;)print(test_doc)for token in test_doc:    print(token, token.lemma_, token.lemma)# 词性标注print(&quot;\n4、词性标注&quot;)print(test_doc)for token in test_doc:    print(token, token.pos_, token.pos)# 命名实体识别print(&quot;\n5、命名实体识别&quot;)test_doc = nlp(u&quot;Rami Eid is studying at Stony Brook University in New York&quot;)print(test_doc)for ent in test_doc.ents:    print(ent, ent.label_, ent.label)# 名词短语提取print(&quot;\n6、名词短语提取&quot;)test_doc = nlp(u&apos;Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.&apos;)print(test_doc)for np in test_doc.noun_chunks:    print(np)# 基于词向量计算两个单词的相似度print(&quot;\n7、基于词向量计算两个单词的相似度&quot;)test_doc = nlp(u&quot;Apples and oranges are the same . Boots and hippos aren&apos;t.&quot;)print(test_doc)apples = test_doc[0]print(apples)oranges = test_doc[2]print(oranges)boots = test_doc[7]print(boots)hippos = test_doc[9]print(hippos)print(apples.similarity(oranges))print(boots.similarity(hippos))</code></pre><p>结果</p><pre><code>/usr/bin/python3.5 /home/wmmm/PycharmProjects/untitled/zstp.py1、分词it&apos;s word tokenize test for spacyit&apos;swordtokenizetestforspacy2、分句Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.Natural language processing (NLP) deals with the application of computational models to text or speech data.Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways.NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form.From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.3、词干化you are best. it is lemmatize test for spacy. I love these booksyou -PRON- 561228191312463089are be 10382539506755952630best good 5711639017775284443. . 12646065887601541794it -PRON- 561228191312463089is be 10382539506755952630lemmatize lemmatize 4507259281035238268test test 1618900948208871284for for 16037325823156266367spacy spacy 10639093010105930009. . 12646065887601541794I -PRON- 561228191312463089love love 3702023516439754181these these 6459564349623679250books book 138144331071114592974、词性标注you are best. it is lemmatize test for spacy. I love these booksyou PRON 94are VERB 99best ADJ 83. PUNCT 96it PRON 94is VERB 99lemmatize ADJ 83test NOUN 91for ADP 84spacy NOUN 91. PUNCT 96I PRON 94love VERB 99these DET 89books NOUN 915、命名实体识别Rami Eid is studying at Stony Brook University in New YorkRami Eid PERSON 378Stony Brook University ORG 381New York GPE 3826、名词短语提取Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.Natural language processingthe applicationcomputational modelsApplication areasNLPautomatic (machine) translationlanguagesdialogue systemsa humana machinenatural languageinformation extractionthe goalunstructured textstructured (database) representationsflexible waysNLP technologiesa dramatic impactthe waypeoplecomputersthe waypeoplethe uselanguagethe waypeoplethe vast amountlinguistic dataelectronic forma scientific viewpointNLPfundamental questionsformal modelsexamplenatural language phenomenaalgorithmsthese models7、基于词向量计算两个单词的相似度Apples and oranges are the same . Boots and hippos aren&apos;t.ApplesorangesBootshippos0.5180960.158362进程已结束,退出代码0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-Python-spaCy-进行简易自然语言处理&quot;&gt;&lt;a href=&quot;#使用-Python-spaCy-进行简易自然语言处理&quot; class=&quot;headerlink&quot; title=&quot;使用 Python+spaCy 进行简易自然语言处理&quot;&gt;&lt;/a&gt;使用 Pytho
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="spacy" scheme="https://yuzhen-li.github.io/tags/spacy/"/>
    
  </entry>
  
  <entry>
    <title>自然语言（分词、分词、实体识别等）集成投票算法实例</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%EF%BC%88%E5%88%86%E8%AF%8D%E3%80%81%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8%E3%80%81%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%E7%AD%89%EF%BC%89%E9%9B%86%E6%88%90%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/自然语言（分词、词性标注、实体识别等）集成投票算法实例/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-16T07:32:42.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源代码注释"><a href="#源代码注释" class="headerlink" title="源代码注释"></a>源代码注释</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#获取数字编号</span><br><span class="line">def numCode(s1_str):</span><br><span class="line">    #s1_str = <span class="string">'|'</span>.<span class="keyword">join</span>(s_str)</span><br><span class="line">    tempNum = <span class="number">1</span></span><br><span class="line">    saveNum = []</span><br><span class="line">    <span class="keyword">for</span> s1_s in s1_str:</span><br><span class="line">        <span class="keyword">if</span> s1_s != <span class="string">'/'</span>:</span><br><span class="line">            saveNum.<span class="keyword">append</span>(tempNum)</span><br><span class="line">        tempNum = tempNum + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> saveNum</span><br><span class="line">#三种分词方法进行融合</span><br><span class="line">def decisonThree(s,s1,s2,s3):</span><br><span class="line">    # s = [<span class="string">'我'</span>, <span class="string">'是'</span>, <span class="string">'招'</span>, <span class="string">'商'</span>, <span class="string">'银'</span>, <span class="string">'行'</span>, <span class="string">'的'</span>, <span class="string">'一'</span>, <span class="string">'员'</span>, <span class="string">'。'</span>]</span><br><span class="line">    # s1 = [<span class="string">'我'</span>, <span class="string">'是'</span>, <span class="string">'招商'</span>, <span class="string">'银行的'</span>, <span class="string">'一员。'</span>]</span><br><span class="line">    # s2 = [<span class="string">'我是'</span>, <span class="string">'招商'</span>, <span class="string">'银行'</span>, <span class="string">'的'</span>, <span class="string">'一员'</span>, <span class="string">'。'</span>]</span><br><span class="line">    # s3 = [<span class="string">'我'</span>, <span class="string">'是招'</span>, <span class="string">'商'</span>, <span class="string">'银行'</span>, <span class="string">'的'</span>, <span class="string">'一员'</span>, <span class="string">'。'</span>]</span><br><span class="line">    a1 = numCode(s1) #我爱你/，/桂/书品/！</span><br><span class="line">    b1 = numCode(s2) </span><br><span class="line">    c1 = numCode(s3)</span><br><span class="line">    <span class="keyword">print</span>(s)</span><br><span class="line">    <span class="keyword">print</span>(s1)#我爱你/，/桂/书品/！</span><br><span class="line">    <span class="keyword">print</span>(a1)#[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>]  遇到/，序号+<span class="number">1</span>，不添加到列表中</span><br><span class="line">    <span class="keyword">print</span>(s2)#我/爱/你/，/桂/书品/！</span><br><span class="line">    <span class="keyword">print</span>(b1)#[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">    <span class="keyword">print</span>(s3)#我/爱/你/，/桂/书品/！</span><br><span class="line">    <span class="keyword">print</span>(c1)#[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">    d1 = []</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(a1)):</span><br><span class="line">        <span class="keyword">if</span> ((a1[i] == b1[i]) <span class="built_in">and</span> (a1[i] == c1[i])):</span><br><span class="line">            d1.<span class="keyword">append</span>(a1[i])</span><br><span class="line">            # <span class="keyword">continue</span></span><br><span class="line">        elif a1[i] == b1[i]:</span><br><span class="line">            d1.<span class="keyword">append</span>(a1[i])</span><br><span class="line">            <span class="keyword">for</span> ii in <span class="built_in">range</span>((i + <span class="number">1</span>), <span class="built_in">len</span>(c1)):</span><br><span class="line">                <span class="keyword">if</span> a1[i] &lt; c1[i]:</span><br><span class="line">                    c1[ii] = c1[ii] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c1[ii] = c1[ii] + <span class="number">1</span></span><br><span class="line">        elif a1[i] == c1[i]:   ##投票算法的核心思想是如果其中两种的分词结果一样，则分词结果为票数多的分词结果。</span><br><span class="line">            d1.<span class="keyword">append</span>(a1[i])</span><br><span class="line">            <span class="keyword">for</span> ii in <span class="built_in">range</span>((i + <span class="number">1</span>), <span class="built_in">len</span>(b1)):</span><br><span class="line">                <span class="keyword">if</span> a1[i] &lt; b1[i]:</span><br><span class="line">                    b1[ii] = b1[ii] - <span class="number">1</span>###使不同的分词+<span class="number">1</span>或者-<span class="number">1</span>，从下一个位置开始比较。</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b1[ii] = b1[ii] + <span class="number">1</span></span><br><span class="line">        elif c1[i] == b1[i]:</span><br><span class="line">            d1.<span class="keyword">append</span>(b1[i])</span><br><span class="line">            <span class="keyword">for</span> ii in <span class="built_in">range</span>((i + <span class="number">1</span>), <span class="built_in">len</span>(a1)):</span><br><span class="line">                <span class="keyword">if</span> b1[i] &lt; a1[i]:</span><br><span class="line">                    a1[ii] = a1[ii] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a1[ii] = a1[ii] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span>(<span class="string">'Decision Fusion:'</span>)</span><br><span class="line">    <span class="keyword">print</span>(d1)#[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">    sumPos = <span class="number">0</span></span><br><span class="line">    listTemp = []</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">max</span>(d1)):</span><br><span class="line">        listTemp.<span class="keyword">append</span>(<span class="string">'|'</span>)</span><br><span class="line">    sNum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">print</span>(listTemp)#[<span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>]，形成d1中数量最大的个数的<span class="string">'|'</span></span><br><span class="line">    <span class="keyword">for</span> nPos in d1:</span><br><span class="line">        listTemp[nPos - <span class="number">1</span>] = s[sNum]</span><br><span class="line">        sNum = sNum + <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span>(listTemp)#[<span class="string">'我'</span>, <span class="string">'|'</span>, <span class="string">'爱'</span>, <span class="string">'|'</span>, <span class="string">'你'</span>, <span class="string">'|'</span>, <span class="string">'，'</span>, <span class="string">'|'</span>, <span class="string">'桂'</span>, <span class="string">'|'</span>, <span class="string">'书'</span>, <span class="string">'品'</span>, <span class="string">'|'</span>, <span class="string">'！'</span>]把listTemp中<span class="string">'|'</span>通过d1的序号提换成s中的字符。</span><br><span class="line">    outputStr = <span class="string">''</span>.<span class="keyword">join</span>(listTemp)</span><br><span class="line">    outputStr = outputStr.<span class="keyword">split</span>(<span class="string">'|'</span>)</span><br><span class="line">    <span class="keyword">print</span>(outputStr)#[<span class="string">'我'</span>, <span class="string">'爱'</span>, <span class="string">'你'</span>, <span class="string">'，'</span>, <span class="string">'桂'</span>, <span class="string">'书品'</span>, <span class="string">'！'</span>]</span><br><span class="line">    <span class="keyword">return</span> outputStr</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;源代码注释&quot;&gt;&lt;a href=&quot;#源代码注释&quot; class=&quot;headerlink&quot; title=&quot;源代码注释&quot;&gt;&lt;/a&gt;源代码注释&lt;/h1&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="分词" scheme="https://yuzhen-li.github.io/tags/%E5%88%86%E8%AF%8D/"/>
    
      <category term="投票集成算法" scheme="https://yuzhen-li.github.io/tags/%E6%8A%95%E7%A5%A8%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>诗和远方1</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B91/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/诗和远方1/</id>
    <published>2018-04-15T13:31:50.000Z</published>
    <updated>2018-04-15T13:32:35.383Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="散文随笔" scheme="https://yuzhen-li.github.io/categories/%E6%95%A3%E6%96%87%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>诗和远方</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/诗和远方/</id>
    <published>2018-04-15T13:17:33.000Z</published>
    <updated>2018-04-15T13:18:11.006Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="散文随笔" scheme="https://yuzhen-li.github.io/categories/%E6%95%A3%E6%96%87%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Stanford_CoreNLP在Ubuntu下的安装与使用</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/Stanford-CoreNLP%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/Stanford-CoreNLP在Ubuntu下的安装与使用/</id>
    <published>2018-04-15T12:22:48.000Z</published>
    <updated>2018-04-15T15:54:27.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stanford-CoreNLP安装以及使用"><a href="#stanford-CoreNLP安装以及使用" class="headerlink" title="stanford CoreNLP安装以及使用"></a>stanford CoreNLP安装以及使用</h1><p>stanford CoreNLP快搞死我了，查了不少资料花费了接近3个小时，才安装完成，并且学会使用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Stanford CoreNLP提供了一系列自然语言分析工具。它能够给出基本的词形，词性，不管是公司名还是人名等，格式化的日期，时间，量词，并且能够标记句子的结构，语法形式和字词依赖，指明那些名字指向同样的实体，指明情绪，提取发言中的开放关系等。如果需要进行如下任务，Standfrod CoreNLP正合适：</p><pre><code>1一个集成的语言分析工具集；2进行快速，可靠的任意文本分析；3.整体的高质量的文本分析;4.支持多种主流语言;5.多种编程语言的易用接口;6.方便的简单的部署web服务。</code></pre><p>Stanford CoreNLP是一个集成的框架。框架的目标是使得应用一大堆语言分析工具分析大量的文本变得简单。COreNLP工具可以仅仅通过两行命令执行大量的文本分析工作。框架设计的初衷就是高度灵活的可扩展性的。通过一个单独的名利ing就可以选择某个工具的开启和关闭。Stanford CoreNLP集成了许多斯坦福的NLP工具，包括：词性标记（POS），命名实体识别（NER），语法，参数分析系统，情绪分析，自举模式学习，和开放信息提取工具。这个框架的分析为高等级和指定领域的文本理解应用程序提供了基本的构件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要安装Java运行环境，以Ubuntu 12.04为例，安装Java运行环境仅需要两步：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> <span class="keyword">default</span>-jre</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">default</span>-jdk</span><br></pre></td></tr></table></figure></p><p>然后下载Stanford coreNLP 包：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://nlp.stanford.edu/software/stanford-corenlp-full<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>.zip</span><br><span class="line"></span><br><span class="line">unzip stanford-corenlp-full<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>.zip</span><br><span class="line"></span><br><span class="line">cd stanford-corenlp-full<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>/</span><br></pre></td></tr></table></figure></p><p>配置环境变量：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `<span class="builtin-name">find</span> . -name <span class="string">"*.jar"</span>`; <span class="keyword">do</span> <span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=<span class="string">"<span class="variable">$CLASSPATH</span>:`realpath <span class="variable">$file</span>`"</span>; done</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `<span class="builtin-name">find</span> /path/<span class="keyword">to</span>/corenlp/ -name <span class="string">"*.jar"</span>`; <span class="keyword">do</span> <span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=<span class="string">"<span class="variable">$CLASSPATH</span>:`realpath <span class="variable">$file</span>`"</span>; done</span><br></pre></td></tr></table></figure><p>安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 <span class="keyword">install</span> stanfordcorenlp</span><br></pre></td></tr></table></figure></p><p>处理中文还需要下载中文的模型jar文件，然后放到stanford-corenlp-full-2018-02-27根目录下即可<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nlp.stanford.edu/software/stanford-chinese-corenlp<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>-models.jar</span><br></pre></td></tr></table></figure></p><h2 id="中文使用方法"><a href="#中文使用方法" class="headerlink" title="中文使用方法"></a>中文使用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"></span><br><span class="line">nlp = StanfordCoreNLP(<span class="string">r'/mnt/f/CMBNLP/stanford-corenlp-full-2018-02-27/'</span>, lang=<span class="string">'zh'</span>) <span class="comment">## 这里是coreNLP的路径</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'清华大学位于北京。'</span></span><br><span class="line"><span class="keyword">print</span> nlp.word_tokenize(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.pos_tag(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.ner(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.parse(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.dependency_parse(sentence)</span><br></pre></td></tr></table></figure><h2 id="英文使用方法"><a href="#英文使用方法" class="headerlink" title="英文使用方法"></a>英文使用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"></span><br><span class="line">nlp = StanfordCoreNLP(<span class="string">r'/mnt/f/CMBNLP/stanford-corenlp-full-2018-02-27/'</span>) <span class="comment">## 这里是coreNLP的路径,与中文相比，省略了, lang='zh'</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'You are a beautiful girl1'</span></span><br><span class="line"><span class="keyword">print</span> nlp.word_tokenize(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.pos_tag(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.ner(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.parse(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.dependency_parse(sentence)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stanford-CoreNLP安装以及使用&quot;&gt;&lt;a href=&quot;#stanford-CoreNLP安装以及使用&quot; class=&quot;headerlink&quot; title=&quot;stanford CoreNLP安装以及使用&quot;&gt;&lt;/a&gt;stanford CoreNLP安装以及
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="NLP" scheme="https://yuzhen-li.github.io/tags/NLP/"/>
    
      <category term="stanford" scheme="https://yuzhen-li.github.io/tags/stanford/"/>
    
      <category term="CoreNLP" scheme="https://yuzhen-li.github.io/tags/CoreNLP/"/>
    
  </entry>
  
</feed>
