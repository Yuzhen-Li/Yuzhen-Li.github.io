<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恩泽の博客</title>
  <icon>https://www.gravatar.com/avatar/366ef683e1866ae1c05b20ceb4ff7fd9</icon>
  <subtitle>有信、有望、有爱。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuzhen-li.github.io/"/>
  <updated>2018-05-25T01:07:53.194Z</updated>
  <id>https://yuzhen-li.github.io/</id>
  
  <author>
    <name>李恩泽(Enze_Li)</name>
    <email>liyuzhen@cmbchina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql与Pandas的联合使用学习</title>
    <link href="https://yuzhen-li.github.io/2018/05/25/Mysql%E4%B8%8EPandas%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yuzhen-li.github.io/2018/05/25/Mysql与Pandas的联合使用学习/</id>
    <published>2018-05-25T01:06:13.000Z</published>
    <updated>2018-05-25T01:07:53.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-与Pandas的联合使用学习"><a href="#Mysql-与Pandas的联合使用学习" class="headerlink" title="Mysql 与Pandas的联合使用学习"></a>Mysql 与Pandas的联合使用学习</h1><h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2><ul><li>启动mysql：输入 net start mysql;</li><li>停止mysql：输入 net stop mysql;</li></ul><h2 id="本地登录"><a href="#本地登录" class="headerlink" title="本地登录"></a>本地登录</h2><p>mysql -u root -p</p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><p>mysql -h mysqlfortest.cuq1n8dfabgn.rds.cn-north-1.amazonaws.com.cn -u mysqlfortest -p</p><p>其中<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlfortest<span class="selector-class">.cuq1n8dfabgn</span><span class="selector-class">.rds</span><span class="selector-class">.cn-north-1</span><span class="selector-class">.amazonaws</span><span class="selector-class">.com</span><span class="selector-class">.cn</span> 为远程数据地址</span><br><span class="line"></span><br><span class="line">mysqlfortest  为远程用户名</span><br></pre></td></tr></table></figure></p><h2 id="已知数据库"><a href="#已知数据库" class="headerlink" title="已知数据库"></a>已知数据库</h2><ul><li>地址:   <code>mysqlfortest.cuq1n8dfabgn.rds.cn-north-1.amazonaws.com.cn</code></li><li>用户名: <code>mysqlfortest</code></li><li>密码:   <code>mysqlfortest</code></li></ul><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>在<code>x_project_data</code>的模式名下有一张表<code>price_per_minute</code>，该表为每分钟的黄金行情数据，现请使用Mysql语句完成以下任务：</p><h3 id="1-展示price-per-minute的字段名称和字段类型；"><a href="#1-展示price-per-minute的字段名称和字段类型；" class="headerlink" title="1.展示price_per_minute的字段名称和字段类型；"></a>1.展示price_per_minute的字段名称和字段类型；</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">use</span> x_project_data;  <span class="comment"># 使用该数据库</span></span><br><span class="line"><span class="attribute">show</span> tables; <span class="comment">#查看该数据库有多少个表</span></span><br><span class="line"><span class="attribute">DESCRIBE</span> price_per_minute; <span class="comment">#描述该表</span></span><br><span class="line"><span class="attribute">select</span> column_name,data_type from information_schema.columns where table_name=<span class="string">'price_per_minute'</span>；显示字段名称和字段类型</span><br></pre></td></tr></table></figure><h3 id="2-针对表price-per-minute展示发布时间trade-time最新的10个交易价格；"><a href="#2-针对表price-per-minute展示发布时间trade-time最新的10个交易价格；" class="headerlink" title="2. 针对表price_per_minute展示发布时间trade_time最新的10个交易价格；"></a>2. 针对表price_per_minute展示发布时间trade_time最新的10个交易价格；</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE price_per_minute; #描述该表</span><br><span class="line"><span class="keyword">SELECT</span> trade_time,close_price <span class="keyword">from</span> price_per_minute <span class="keyword">ORDER</span> <span class="keyword">BY</span> trade_time <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="3-统计每天会有多少条记录，并且按照日期逆序进行排列；"><a href="#3-统计每天会有多少条记录，并且按照日期逆序进行排列；" class="headerlink" title="3.统计每天会有多少条记录，并且按照日期逆序进行排列；"></a>3.统计每天会有多少条记录，并且按照日期逆序进行排列；</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(trade_time,<span class="string">'%Y-%m-%d'</span>),<span class="built_in">COUNT</span>(*) <span class="keyword">from</span> price_per_minute <span class="keyword">GROUP</span> <span class="keyword">BY</span> DATE_FORMAT(trade_time,<span class="string">'%Y-%m-%d'</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span>  DATE_FORMAT(trade_time,<span class="string">'%Y-%m-%d'</span>) <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#除了使用DATE_FORMAT，还可以利用函数Date()将提取出日期中的年月日</span><br><span class="line"><span class="keyword">SELECT</span> Date(trade_time),<span class="built_in">COUNT</span>(*) <span class="keyword">from</span> price_per_minute <span class="keyword">GROUP</span> <span class="keyword">BY</span>  Date(trade_time) <span class="keyword">ORDER</span> <span class="keyword">BY</span>  Date(trade_time) <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#统计一列中的值重复出现的次数，查询出的结果按次数的倒序排列</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 重复字段，<span class="built_in">count</span>(*) <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段 <span class="keyword">order</span> <span class="keyword">by</span> 重复字段 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="4-建立一个跟price-per-minute表结构一样的表price-per-minute-bak，添加一列名为’newtag’的列，列的类型为’char’；"><a href="#4-建立一个跟price-per-minute表结构一样的表price-per-minute-bak，添加一列名为’newtag’的列，列的类型为’char’；" class="headerlink" title="4.建立一个跟price_per_minute表结构一样的表price_per_minute_bak，添加一列名为’newtag’的列，列的类型为’char’；"></a>4.建立一个跟price_per_minute表结构一样的表price_per_minute_bak，添加一列名为’newtag’的列，列的类型为’char’；</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE A LIKE <span class="keyword">B </span><span class="comment">#此种方式在将表B复制到A时候会将表B完整的字段结构和索引复制到表A中来。</span></span><br><span class="line">CREATE TABLE A AS SELECT * FROM <span class="keyword">B </span>LIMIT <span class="number">0</span> <span class="comment">#此种方式只会将表B的字段结构复制到表A中来，但不会复制表B中的索引到表A中来。这种方式比较灵活可以在复制原表表结构的同时指定要复制哪些字段，并且自身复制表也可以根据需要增加字段结构。</span></span><br><span class="line"></span><br><span class="line">两种方式在复制表的时候均不会复制权限对表的设置。比如说原本对表<span class="keyword">B做了权限设置，复制后，表A不具备类似于表B的权限。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">另外：oracle支持as，也是只有表结构没有索引；oracle不支持like。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">CREATE </span>TABLE price_per_minute_bak LIKE price_per_minute<span class="comment">;</span></span><br><span class="line">ALTER TABLE price_per_minute_bak <span class="keyword">add </span>column newtag char(<span class="number">20</span>) not null<span class="comment">; #新添加一列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想删除某一列可以用下面的命令</span></span><br></pre></td></tr></table></figure><h4 id="新表中将现有的base-currency类型由char-8-改成char-16"><a href="#新表中将现有的base-currency类型由char-8-改成char-16" class="headerlink" title="新表中将现有的base_currency类型由char(8)改成char(16)"></a>新表中将现有的base_currency类型由char(8)改成char(16)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> price_per_minute_bak <span class="keyword">modify</span> <span class="keyword">column</span> base_currency <span class="built_in">char</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h4 id="把最终建好的表字段进行展示"><a href="#把最终建好的表字段进行展示" class="headerlink" title="把最终建好的表字段进行展示"></a>把最终建好的表字段进行展示</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> price_per_minute_bak;</span><br></pre></td></tr></table></figure><h4 id="5-将表与event-history进行关联（内连接，关联的键分别为trade-time-和-related-event-datetime-统计关联结果的数量，删除新建的表price-per-minute-bak："><a href="#5-将表与event-history进行关联（内连接，关联的键分别为trade-time-和-related-event-datetime-统计关联结果的数量，删除新建的表price-per-minute-bak：" class="headerlink" title="5.将表与event_history进行关联（内连接，关联的键分别为trade_time 和 related_event_datetime)统计关联结果的数量，删除新建的表price_per_minute_bak："></a>5.将表与event_history进行关联（内连接，关联的键分别为trade_time 和 related_event_datetime)统计关联结果的数量，删除新建的表price_per_minute_bak：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INNER JOIN 关联两张数据表的写法：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段号=表<span class="number">2.</span>字段号</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 关联三张数据表的写法：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段号=表<span class="number">2.</span>字段号) <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段号=表<span class="number">3.</span>字段号</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">SELECT</span> a.trade_time <span class="keyword">from</span> price_per_minute a </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> event_history b</span><br><span class="line"><span class="keyword">ON</span> a.trade_time = b.related_event_datetime) c;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> price_per_minute_bak;</span><br></pre></td></tr></table></figure><h3 id="6-python环境安装sqlalchemy，-用sqlalchemy-配置数据库字段，访问price-per-minute数据，将读取后的数据放入pandas-dataframe中，使用pandas函数完成以下功能："><a href="#6-python环境安装sqlalchemy，-用sqlalchemy-配置数据库字段，访问price-per-minute数据，将读取后的数据放入pandas-dataframe中，使用pandas函数完成以下功能：" class="headerlink" title="6. python环境安装sqlalchemy， 用sqlalchemy 配置数据库字段，访问price_per_minute数据，将读取后的数据放入pandas.dataframe中，使用pandas函数完成以下功能："></a>6. python环境安装<code>sqlalchemy</code>， 用<code>sqlalchemy</code> 配置数据库字段，访问<code>price_per_minute</code>数据，将读取后的数据放入<code>pandas.dataframe</code>中，使用<code>pandas</code>函数完成以下功能：</h3><pre><code>1. 添加新的一列’diff’,该列保存每一分钟与上一分钟的close价格差，    * 求出价格差异最大的值以及相应的时刻    * 画出diff这一列的直方图分布2. 保存每天的最后一笔交易数据，过滤其他的日内交易数据；3. 画出close随时间trade_time变化的曲线图；4. 将最终得到的dataframe保存为’自己姓名.csv’的文件</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.dates <span class="keyword">as</span> mdates</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库连接:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    engine = create_engine(<span class="string">'mysql://mysqlfortest:mysqlfortest@mysqlfortest.cuq1n8dfabgn.rds.cn-north-1.amazonaws.com.cn/x_project_data'</span>)</span><br><span class="line">    <span class="comment">#1 上面的create_engine就是用来连接数据库的引擎：</span></span><br><span class="line">    <span class="comment">#2 mysql+pymysql指定使用pymysql来执行原生SQL语句</span></span><br><span class="line">    <span class="comment">#3 //root:1@127.0.0.1/tomdb   &lt;&lt;==&gt;&gt; //用户名：密码@ip/数据库名</span></span><br><span class="line">    <span class="comment">#4 encoding='utf-8' 指定创建的表用‘utf-8'编码（可以存中文）</span></span><br><span class="line">    <span class="comment">#5 echo=True 将执行SQL原生语句的执行细节打印出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将sql中的数据读取到dataframe中</span></span><br><span class="line">    sql_cmd = <span class="string">"Select * from price_per_minute ORDER BY trade_time DESC limit 15000 "</span> ; <span class="comment">#时间降序排列，从上到下为 现在的时间到过去的时间</span></span><br><span class="line">    Data = pd.read_sql(sql_cmd, engine)  <span class="comment">#read_sql接受两个参数，一个是sql语句;一个是con（数据库连接）、read_sql直接返回一个DataFrame对象</span></span><br><span class="line">    print(Data);</span><br><span class="line">    <span class="comment">#1. 添加新的一列’diff’,该列保存每一分钟与上一分钟的close价格差， 现在的时间减去过去的时间，上-下，为一阶差分</span></span><br><span class="line">    Data[<span class="string">'diff'</span>] = Data[<span class="string">'close_price'</span>].diff(<span class="number">-1</span>) <span class="comment">#向下差分；</span></span><br><span class="line">    <span class="comment">## * 求出价格差异最大的值以及相应的时刻</span></span><br><span class="line">    diff = Data[<span class="string">'diff'</span>];</span><br><span class="line">    max_diff =  diff.max();</span><br><span class="line">    max_index = np.argmax(diff); <span class="comment">#numpy 的函数argmax 求数组中最大值对应的索引</span></span><br><span class="line">    max_trade_time = Data[<span class="string">'trade_time'</span>][max_index];</span><br><span class="line">    print(<span class="string">'最大价格差值===='</span>+str(max_diff));</span><br><span class="line">    print(<span class="string">'最大价差对应交易时间===='</span>+str(max_trade_time))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#画出diff这一列的直方图分布</span></span><br><span class="line">    plt.figure(<span class="number">1</span>);</span><br><span class="line">    plt.subplot(<span class="number">211</span>);</span><br><span class="line">    <span class="comment">#n, bins, patches = plt.hist(diff,20);</span></span><br><span class="line">    </span><br><span class="line">    diff.hist(bins=<span class="number">5</span>);</span><br><span class="line">    <span class="comment">#plt.hist(diff,bins = 15, color = "red", normed = True);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#2. 保存每天的最后一笔交易数据，过滤其他的日内交易数据；</span></span><br><span class="line">    Res = Data.resample(<span class="string">'1D'</span>,on=<span class="string">'trade_time'</span>).last(); <span class="comment"># 将DataFrame按照天来分组 取每组（天）的最后一组交易数据；</span></span><br><span class="line">    print(Res);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#  3. 画出close随时间trade_time变化的曲线图；</span></span><br><span class="line">    months = mdates.MonthLocator();</span><br><span class="line">    days = mdates.DayLocator();</span><br><span class="line">    timeFmt = mdates.DateFormatter(<span class="string">'%Y-%m'</span>)</span><br><span class="line">    closeprice = Data[<span class="string">'close_price'</span>]</span><br><span class="line">    tradetime = Data[<span class="string">'trade_time'</span>]</span><br><span class="line">    ax = plt.subplot(<span class="number">212</span>);</span><br><span class="line">    plt.plot(tradetime,closeprice);</span><br><span class="line">    <span class="comment">#ax.xaxis.set_major_locator(months);</span></span><br><span class="line">    <span class="comment">#ax.xaxis.set_major_formatter(timeFmt);</span></span><br><span class="line">    <span class="comment">#ax.xaxis.set_minor_locator(days);</span></span><br><span class="line">    plt.show();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#4. 将最终得到的dataframe保存为’自己姓名.csv’的文件</span></span><br><span class="line">    Data.to_csv(<span class="string">'liyuzhen.csv'</span>,index=<span class="keyword">False</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql-与Pandas的联合使用学习&quot;&gt;&lt;a href=&quot;#Mysql-与Pandas的联合使用学习&quot; class=&quot;headerlink&quot; title=&quot;Mysql 与Pandas的联合使用学习&quot;&gt;&lt;/a&gt;Mysql 与Pandas的联合使用学习&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="pandas" scheme="https://yuzhen-li.github.io/tags/pandas/"/>
    
      <category term="MySQL - python" scheme="https://yuzhen-li.github.io/tags/MySQL-python/"/>
    
  </entry>
  
  <entry>
    <title>怎么基于开源区块链项目Hyperledger-fabric进行简单应用</title>
    <link href="https://yuzhen-li.github.io/2018/05/18/%E6%80%8E%E4%B9%88%E5%9F%BA%E4%BA%8E%E5%BC%80%E6%BA%90%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AEHyperledger-fabric%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>https://yuzhen-li.github.io/2018/05/18/怎么基于开源区块链项目Hyperledger-fabric进行简单应用/</id>
    <published>2018-05-18T03:44:30.000Z</published>
    <updated>2018-05-18T03:48:17.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么基于开源区块链项目Hyperledger-fabric进行简单应用"><a href="#怎么基于开源区块链项目Hyperledger-fabric进行简单应用" class="headerlink" title="怎么基于开源区块链项目Hyperledger-fabric进行简单应用"></a>怎么基于开源区块链项目Hyperledger-fabric进行简单应用</h1><hr><h2 id="一、区块链从何而来？如何简单的理解"><a href="#一、区块链从何而来？如何简单的理解" class="headerlink" title="一、区块链从何而来？如何简单的理解?"></a>一、区块链从何而来？如何简单的理解?</h2><p>区块链是比特币的核心技术，而比特币最初是以按照货币来设计的，所以先阐述下货币的三个主要功能：</p><ul><li><p>交易媒介-&gt;货币可以用来购买产品或者服务</p></li><li><p>记账单位-&gt;可以作为价值衡量的手段</p></li><li><p>价值储藏-&gt;跨时间段的购买力和储藏</p><pre><code>**区块链即满足了第二点，所以我们可以把它看做一个自带对账功能的账本。**</code></pre></li></ul><p>区块链属于一种去中心化的记录技术。参与到系统上的节点，可能不属于同一组织、彼此无需信任；区块链数据由所有节点共同维护，每个参与维护节点都能复制获得一份完整记录的拷贝。</p><h2 id="那么区块链又跟传统的记账技术有什么区别呢？"><a href="#那么区块链又跟传统的记账技术有什么区别呢？" class="headerlink" title="那么区块链又跟传统的记账技术有什么区别呢？"></a>那么区块链又跟传统的记账技术有什么区别呢？</h2><p><strong>其特点应该包括：</strong></p><ul><li>维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改；</li><li>去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式；</li><li>通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性。</li><li>可以将智能合约跟区块链结合到一起，让其提供除了交易（比特币区块链已 经支持简单的脚本计算）功能外更灵活的合约功能，执行更为复杂的操作</li></ul><h2 id="区块链的基本概念"><a href="#区块链的基本概念" class="headerlink" title="区块链的基本概念"></a>区块链的基本概念</h2><ul><li>交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录；</li><li>区块（Block） ：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识；</li><li>链（Chain） ：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。</li></ul><h2 id="一句话解释"><a href="#一句话解释" class="headerlink" title="一句话解释"></a>一句话解释</h2><p><strong>可以把区块链看作是一个==状态机==，则每次交易就是试图改变一次状态，参与者对于区块中所有交易内容导致状态改变的结果达成共识后生成区块，而区块之间以密码学特征(如Hash值)方式按先后顺序链接起来，形成以区块为基本单元的”链”,并且将该”链”在区块链网络参与节点间复制和共享，同时链上内容依据不同的共识机制由参与节点组成的网络集体维护。</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据参与者的不同，可以分为公开链、联盟链和私有链。</p><h2 id="公开链"><a href="#公开链" class="headerlink" title="公开链"></a>公开链</h2><p>顾名思义，任何人都可以参与使用和维护，典型的如比特币区块链，信息是完全公开的。</p><h2 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h2><p>则是集中管理者进行限制，只能得到内部少数人可以使用，信息不公开。</p><h2 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h2><p>则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是有权限的管理，相关信息会得到保护，典型如银联组织。</p><h2 id="区块链涉及技术"><a href="#区块链涉及技术" class="headerlink" title="区块链涉及技术"></a>区块链涉及技术</h2><p>区块链涉及到的领域比较杂，包括分布式、存储、密码学、心理学、经济 学、博弈论、网络协议等。</p><h3 id="密码学相关技术"><a href="#密码学相关技术" class="headerlink" title="密码学相关技术"></a>密码学相关技术</h3><p>包括 hash 算法与摘要、加密算法、数字签名和证书、PKI 体系、Merkle 树、同态加密等后面涉及到再介绍，忘记介绍了就自行百度。</p><h3 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h3><p>如比特币基于博弈论提出了工作量证明”（Proof of Work） 策略等。让恶意破坏的参与者损失经济利益，从而保证大部分人的合作。PoS、DPoS 、Casper 、Paxos、拜占庭、 PBFT、二阶段提交、三阶段提交、Gossip等。等后面涉及到相关的再介绍，忘记介绍了就自行百度。</p><p>好，认识了以上基本概念，理解我们的重点Hyperledger-Fabric就容易多了.</p><h2 id="Hyperledger-Fabric-IBM主推的区块链开源项目"><a href="#Hyperledger-Fabric-IBM主推的区块链开源项目" class="headerlink" title="Hyperledger-Fabric-IBM主推的区块链开源项目"></a>Hyperledger-Fabric-IBM主推的区块链开源项目</h2><p>Fabric的架构图如下：<br>核心组件：</p><ol><li>节点(Peer)<br>在网络中具有一定功能的服务或者软件。它在Fabric网络中，主要负责接收交易请求。维护账本，一般都是运行在容器。节点之间通过gRPC进行通信。 在Fabric中，Peer主要有三种类型Endorser(背书节点):负责对交易提案进行检查背书。 Committer(确认节点)：负责检查交易请求，执行交易，并维护区块链和账本结构。</li><li>排序者(Orderer)<br>负责对收到的交易在网络中进行全局排序。</li><li>CA节点<br>负责对网络中的成员身份进行管理，目前采用的事数字证书机制，CA节点实现了PKI服务。<br><strong>数字签名和数字证书</strong><br>数字签名 类似在纸质合同上签名确认合同内容，数字签名用于<strong>证实某数字内容的完整性和来源</strong>。A发给B一个文件。A先对文件进行摘要，然后用自己的私钥进行加密，将文件和加密串都发给B。B收到后文件和加密串，用A的公钥来解密加密串，得到原始的数字摘要，跟对文件进行摘要后的结果进行比对。如果一致，说明该文件确实是 A 发过来的，并且文件内容没 有被修改过。<br>数字证书用来证明某个公钥是谁的。对于数字签名应用来说，很重要的一点就是公钥的分发。一旦公钥被人替换，则整个安全体 系将被破坏掉。 怎么确保一个公钥确实是某个人的原始公钥？ 这就需要数字证书机制。<br>数字证书就是像一个证书一样，证明信息和合法性。由证书认证机构（Certification Authority，CA） 来签发。<br>数字证书内容可能包括版本、序列号、签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥、CA数字签名、其它信息等等。其中，最重要的包括 <strong>签发的公开密钥、CA数字签名</strong>两个信息。因此，只要通过这个证书就能 证明某个公钥是合法的，因为带有CA的数字签名。更进一步地，怎么证明 CA 的签名合法不合法呢？ 类似的，CA的数字签名合法不合法也是通过 CA 的证书来证明的。<br><strong>PKI 体系 PKI （Public Key Infrastructure）</strong><br>它不是某一种技术，而是综合多种密码学手段来实现安 全可靠传递消息和身份确认的一个框架和规范。 一般情况下，包括如下组件： CA（Certification Authority） ：负责证书的颁发和作废，接收来自 RA 的请求； RA（Registration Authority）：对用户身份进行验证，校验数据合法性，负责登记，审 核过了就发给 CA； 证书数据库：存放证书，一般采用 LDAP 目录服务，标准格式采用 X.500 系列。<br>CA是最核心的组件，主要完成对公钥的管理。密钥有两种 类型：用于签名和用于加解密，对应称为 签名密钥对 和 加密密钥对 。 用户基于 PKI 体系要申请一个证书，一般可以由 CA 来生成证书和私钥，也可以自己生成公 钥和私钥，然后由 CA 来对公钥进行签发。</li><li>组织<br>拥有共同信任的根证书(如根CA证书)的成员的集合。 Fabric组织中的成员由于拥有共同的信任根，所以可以交换比较敏感的内容。 组织一般包括名称，ID,MSP信息，管理策略，认证采用的密码类型等信息。 多个组织为了便于沟通，可以加入同一通道。如三家银行，一共三个组织，两两加入到同一个通道中彼此就可以进行相关的数据交互。</li><li>联盟<br>若干个组织的集合</li><li>交易<br>可以把Fabric中的每一次请求都看成一次交易，要构造一次交易，首先要创建交易提案，当一个交易提案获得足够的背书支持的时候，再构造出合法的交易请求，然后发送给排序节点进行排序，排序完成后，会广播到网络中的各个节点进行确认，如果节点对交易进行本地验证通过，则更新本地账本。</li><li>区块<br>一组排序后的交易集合。 区块结构包含区块头(Header)，数据(Data),元数据(Metadata). 区块头用于构建区块链结构，包括Number,PerviousHash,DataHash. Number记录区块的序号，PerviousHash记录梭关联的前一个区块的头部域的Hash值，DataHash为本区块Data域的Hash值。 Data域中以Envelope结构记录区块的多个交易信息，这些交易采用Merkle树结构进行组织。<br>Merkle 树（又叫哈希树）<br>是一种二叉树，由一个根节点、一组中间节点和一组叶节点组成。 最下面的叶节点包含存储数据或其哈希值，每个中间节点是它的两个孩子节点内容的哈希值，根节点也是由它的两个子节点内容的哈希值组成。<br>Merkle树的特点是，底层数据的任何变动，都会传递到其父亲节点，一直到树根。 Merkle树的典型应用场景包括： 快速比较大量数据：当两个默克尔树根相同时，则意味着所代表的数据必然相同。 快速定位修改：可以快速定位到发生改变的节点；</li><li><p>链码<br>即智能合约。</p></li><li><p>通道<br>通道与绑定到该通道上的配置和数据(包括交易，账本，链码实例，成员身份等)一起构成一条完整的区块链，这些数据只会被加入到通道的组织成员所感知和访问到，通道外的成员无法访问到通道内的数据。Fabric中的通道分为应用通道和系统通道，前者供用户使用，负责承载各种交易。后者则负责对应用通道的管理。<br>通道在创建的时候，会指定所关联的访问策略，初始化所包括的组织身份(证书范围等，通过MSP校验)，锚节点，Orderer服务地址等。通道创建后会构成一条区块链结构，初始区块中包含初始配置相关的信息。<br>我们创建新的应用通道时，需要向系统通道发送配置交易，同时配置交易所构成的区块，会作为新建应用通道的初始区块。</p></li><li>账本(ledger)<br>可以看作是数据储存结构了，主要包括状态数据库:记录区块链结构中的交易执行过程。记录最新的状态。<br>索引数据库：存放索引信息，例如从Hahs，编号索引到区块，从ID索引到交易等。<br>历史数据库：存放各个状态的历史变化记录。<br>备注:Fabric的区块链结构主要通过文件系统进行存储；状态数据库目前支持LevelDB,CounchDB.<h2 id="记录账本流程"><a href="#记录账本流程" class="headerlink" title="记录账本流程"></a>记录账本流程</h2>应用程序通过SDK发送请求到Peer节点（一个或多个）peer节点分别执行交易（通过chaincode），但是并不将执行结果提交到本地的账本中（可以认为是模拟执行，交易处于挂起状态），参与背书的peer将执行结果返回给应用程序（其中包括自身对背书结果的签名），应用程序收集背书结果，并将结果提交给Ordering服务节点，Ordering服务节点执行共识过程并生成block，通过消息通道发布给Peer节点，由peer节点各自验证交易并提交到本地的ledger中（包括state状态的变化）。<br>关于通道：通道是有共识服务（ordering）提供的一种通讯机制，类似于消息系统中的发布-订阅（PUB/SUB)中的topic；基于这种发布-订阅关系，将peer和orderer连接在一起，形成一个个具有保密性的通讯链路（虚拟），实现了业务隔离的要求；通道也与账本（ledger）-状态（worldstate）紧密相关；<br>共识服务与（P1、PN）、（P1、P2、P3）、（P2、P3）组成了三个相互独立的通道，加入到不同通道的Peer节点能够维护各个通道对应的账本和状态；也其实也对应现实世界中，不同业务场景下的参与方，例如银行、保险公司；物流企业、生产企业等实体结构；<br>整個Fabric的安裝部署就不在这一一细讲了，感兴趣的可以私下找我。这里主要解释怎么进行开发，以及一些对应的解读。</li></ol><p>具体步骤如下： 一：新建yjmtest.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    pb <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> SimpleChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(SimpleChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Error starting Simple chaincode: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"Init OK!  params:::"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    function, args := stub.GetFunctionAndParameters()</span><br><span class="line">    fmt.Println(<span class="string">"invoke is running "</span> + function)</span><br><span class="line">    <span class="keyword">if</span> function == <span class="string">"test"</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.testYJM(stub, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"delete"</span> &#123;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">return</span> t.deletePerson(stub, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"query"</span> &#123;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">return</span> t.queryPerson(stub, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"create"</span> &#123;</span><br><span class="line">    <span class="comment">// cchuangjian</span></span><br><span class="line">    <span class="keyword">return</span> t.createPerson(stub, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">"Received unknown function=="</span> + <span class="keyword">string</span>(function) + <span class="string">":::args:::"</span> + <span class="keyword">string</span>(args[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">testYJM</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"-------------Called testYJM  hello world------------"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">createPerson</span><span class="params">(stub shim.ChaincodeStubInterface, params []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    sname := params[<span class="number">0</span>]</span><br><span class="line">    person := &amp;Person&#123;</span><br><span class="line">    Name: sname,</span><br><span class="line">    &#125;</span><br><span class="line">    personJsonBytes, err := json.Marshal(person) <span class="comment">//Json序列号</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    err = stub.PutState(sname, personJsonBytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"create Person success!"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//刪除</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">deletePerson</span><span class="params">(stub shim.ChaincodeStubInterface, params []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="comment">//params := stub.GetStringArgs()</span></span><br><span class="line">    key := params[<span class="number">0</span>] <span class="comment">//name</span></span><br><span class="line">    err := stub.DelState(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">"Failed to delete Person from DB, key is: "</span> + key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"delete Person success!"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查詢</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">queryPerson</span><span class="params">(stub shim.ChaincodeStubInterface, params []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="comment">//params := stub.GetStringArgs()</span></span><br><span class="line">    key := params[<span class="number">0</span>] <span class="comment">//name</span></span><br><span class="line">    dbPersonBytes, err := stub.GetState(key)</span><br><span class="line">    <span class="keyword">var</span> person Person</span><br><span class="line">    err = json.Unmarshal(dbPersonBytes, &amp;person) <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">"&#123;\"Error\":\"Failed to decode JSON of: "</span> + <span class="keyword">string</span>(dbPersonBytes) + <span class="string">"\" to Person&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"query Person from DB, name:"</span> + person.Name)</span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"query Person success!"</span>))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>对应解读：</strong><br>目前是基于fabric-1.0.0版本进行开发（最新版本刚出1.0.1），开发方式可以基于SDK和链码。当然由于太新了，SDK还不太成熟，所以就给大家示范了下基于链码的方式，本来也想用java弄的，后面发下坑太大，目前还趟不过去，就选择了相对容易的方式。</p><p>链码就是智能合约，也可以理解成一个服务，里面可以有很多我们自定义的方法，我们的自定义方法都是通过invoke来进行调用，除了用if-else來判断对应的方法，当然也可以使用fabric提供的状态机，这里就不在演示。此外可以引用第三方包，放入到import里面就可以使用，所以我们可以把自己的代码打包然后到进来直接使用，go是可以直接从github上引用的，只要把我们自己放在github上包的路径引进来即可。此外，当前链码还可以引用其它链码，所以可以理解为一个服务可以调用另外的服务，所以可以实现相对复杂的业务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    pb <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> SimpleChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(SimpleChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Error starting Simple chaincode: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"Init OK!  params:::"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    function, args := stub.GetFunctionAndParameters()</span><br><span class="line">    fmt.Println(<span class="string">"invoke is running "</span> + function)</span><br><span class="line">    <span class="keyword">if</span> function == <span class="string">"test"</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.testYJM(stub, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">"Received unknown function=="</span> + <span class="keyword">string</span>(function) + <span class="string">":::args:::"</span> + <span class="keyword">string</span>(args[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">testYJM</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"-------------Called testYJM  hello world------------"</span>))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="必须要引入的包"><a href="#必须要引入的包" class="headerlink" title="必须要引入的包"></a>必须要引入的包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">pb <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br></pre></td></tr></table></figure><p>shim是fabric和我們的交互接口。ChaincodeStubInterface就就相当与我们平时理解的Dao层，可以进行相关的数据操作。它在/go/src/github.com/hyperledger/fabric/core/chaincode/shim/interfaces.go定义，在chaincode.go中实现。感兴趣的可以自己查看。</p><p>shim.ChaincodeStubInterface APIs如下:</p><p>账本交互API</p><p>API| 方法格式 | 简单说明</p><ul><li>GetState | GetState(key String)([]byte,error) | 根據键查詢賬本</li><li>PutState | GetState(key String,value []byte) | 添加</li><li>DelState|…| …</li><li>GetStateByRange | GetStateByRange(startKey,endKey string)(StateQueryIteratorInterface,error)|查詢指定范围的键值，返回结果是个迭代器。</li><li>GetByHistoryForKey|GetByHistoryForKey（key String）(QueryIteratorInterface,error) | 返回某个键的所有历史</li><li>GetQueryResult| GetQUeryResult（key String）(QueryIteratorInterface,error) |支持富查询，不过目前只有CouchDB支持</li></ul><p>交易相关API</p><p>API| 方法格式 | 简单说明</p><ul><li>GetTxID | GetState(key String)([]byte,error)</li></ul><p>参数读取API </p><p>API| 方法格式 | 简单说明</p><ul><li>GetFunctionAndParameters解析调用的时候传入的参数 | GetFunctionAndParameters() (string, []string) |解析调用的时候传入的参数。</li><li>GetArgs | GetArgs() [][]byte|以byte数组的数组的形式获得传入的参数列表</li><li>GetStringArgs|GetStringArgs() []string |以字符串数组的形式获得传入的参数列表<br>注：API详细说明： <a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim" target="_blank" rel="noopener">https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim</a></li></ul><p>  二：将代码放到/home/yjm/go/src/github.com/hyperledger/fabric/examples/chaincode/go/yjmtest/路径（为什么要放到这个路径后面会解释，稍安勿躁）</p><p>  三：进入到/home/yjm/go/src/github.com/hyperledger/fabric/examples/e2e_cli路径下，启动终端。</p><p>  四：输入network_setup.sh up启动整个区块链网络 启动成功结果如下：</p><p>  五：/home/yjm/go/src/github.com/hyperledger/fabric/examples/e2e_cli路径下输入如下命令进入到容器:</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> cli bash</span><br></pre></td></tr></table></figure><p>  六：输入如下命令安装链码:</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -n yjmtest -v <span class="number">1.0</span> -p github.com/hyperledger/fabric/examples/chaincode/<span class="keyword">go</span>/yjmtest</span><br></pre></td></tr></table></figure><p>  七：输入如下命令颁发证书（否则后面没有权限实例化链码）:<br>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORDERER_CA=<span class="regexp">/opt/g</span>opath<span class="regexp">/src/gi</span>thub.com<span class="regexp">/hyperledger/</span>fabric<span class="regexp">/peer/</span>crypto<span class="regexp">/ordererOrganizations/</span>example.com<span class="regexp">/orderers/</span>orderer.example.com<span class="regexp">/msp/</span>tlscacerts<span class="regexp">/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure></p><p>  八：实例化链码:<br>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer<span class="selector-class">.example</span><span class="selector-class">.com</span>:<span class="number">7050</span> --tls true --cafile <span class="variable">$ORDERER_CA</span> -C mychannel -n testyjm -v <span class="number">1.0</span> -c <span class="string">'&#123;"Args":[]&#125;'</span></span><br></pre></td></tr></table></figure></p><p>  九：执行命令进行相关操作<br>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode <span class="keyword">query</span> -C mychannel -<span class="keyword">n</span> yjmtest -c '&#123;<span class="string">"Function"</span>:<span class="string">"create"</span>,<span class="keyword">Args</span><span class="string">":["</span>yejunmeng"]&#125;'</span><br></pre></td></tr></table></figure></p><p>对应解读：<br>Fabric的链码分为系统链码和用户链码。</p><p>系统链码与一般chaincode一样，有相同的编程模型，只不过系统链码是运行在peer程序中，即其是peer程序的一部分，而一般的chaincode是单独运行在一个容器中的。因此，系统链码是内建在peer程序中且不遵循一般chaincode那样的生命周期。特别的，install，instantiate和upgrade操作也不应用于系统链码。</p><p>系统链码区别与一般的chaincode的目的是缩短grpc在peer结点与chaincode之间通信的时间消耗（因为peer结点在一个容器，chaincode是单独的一个容器），并权衡管理上的灵活性。比如，一个系统链码可以仅通过升级peer程序的二进制包来得到升级。系统链码可以用预定义的元素注册并编译到peer程序中，而且不需要有类似于背书策略或背书功能等这样的冗杂的功能。</p><p>系统链码被用在fabric中，去操纵整个系统的配置表现，这样的话可以随时把系统改变到合适的状态。</p><p><strong>几个系统链码如下：</strong></p><p>LSCC Lifecycle system chaincode，处理生命周期请求。我理解的生命周期请求应该指的是一个chaincode的安装，实例化，升级，卸载等对其生命周期起关键作用的一系列操作请求。</p><p>CSCC Configuration system chaincode，处理在peer程序端的频道配置。</p><p>QSCC Query system chaincode，提供账本查询接口，如获取块和交易信息。</p><p>ESCC Endorsement system chaincode，通过对交易申请的应答信息进行签名，来提供背书功能。</p><p>VSCC Validation system chaincode，处理交易校验，包括检查背书策略和版本在并发时的控制。</p><p>链码操作支持的常见命令参数</p><p>参数 | 含义</p><pre><code>这里是列表文本-C，-chainID| 所面向的通道 -c，ctor| 链码的具体执行参数信息，Json格式 -E，escc | 指定背书系统链码的名称 -l，lang | 链码的 编写语言 -n，name | 链码名称 -o，orderer | orderder服务地址 -P，policy | 链码所关联的背书策略 ..... | ......</code></pre><p>关于整个系统链码，以下统称为SCC， 用户链码，以下统称为ACC。<br>SCC启动占用的是inproc容器，可以当作就是内存里概念上的容器，在core/container/inproccontroller下实现。 ACC启动占用的是docker容器，在core/container/dockercontroller下实现。</p><p>chaincode接口是定义在core/chaincode/shim/interfaces.go中的Chaincode，只有两个接口：Init(stub)和Invoke(stub)，统一用同文件中的ChaincodeStubInterface接口实例作为唯一的参数。</p><p>ChaincodeStubInterface接口唯一的实现是在同目录下的chaincode.go中的ChaincodeStub。</p><p>每一个chaincode都会起两个Handler，每一个Handler都是一个以状态机（FSM）驱动的通信机器，在驱动的过程中执行具体的状态事件，完成一个chaincode所需做的事情。一个可以称为服务端Handler（相当于服务端）实现在core/chaincode/handler.go中，另一个可以称为shim端Handler（相当于客户端），实现在core/chaincode/shim/handler.go中。</p><p>core/chaincode下的为chaincode服务端的代码，主要用于处理chaincode的请求；core/chaincode/shim下的为chaincode客户端的代码，用于定义供开发者使用的接口和客户端提交申请。</p><p>一个chaincode实质还是一个结构体对象，该结构体实现了Chaincode接口。SCC如core/scc/lscc/lscc.go中的LifeCycleSysCC。</p><p>ACC如examples/chaincode/go/chaincode_example01/chaincode_example01.go中的SimpleChaincode。</p><h2 id="ACC的安装过程"><a href="#ACC的安装过程" class="headerlink" title="ACC的安装过程"></a>ACC的安装过程</h2><p>当整个Fabric网络启动的时候回去读取docker-compose-cli.yaml</p><p>docker-compose-cli.yaml内容如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">  #</span><br><span class="line">  # SPDX-License-Identifier: Apache<span class="number">-2.0</span></span><br><span class="line">  #</span><br><span class="line">  </span><br><span class="line">  version: <span class="string">'2'</span></span><br><span class="line">  </span><br><span class="line">  services:</span><br><span class="line">  </span><br><span class="line">    orderer.example.com:</span><br><span class="line">      extends:</span><br><span class="line">        file:   base/docker-compose-base.yaml</span><br><span class="line">        service: orderer.example.com</span><br><span class="line">      container_name: orderer.example.com</span><br><span class="line">  </span><br><span class="line">    peer0.org1.example.com:</span><br><span class="line">      container_name: peer0.org1.example.com</span><br><span class="line">      extends:</span><br><span class="line">        file:  base/docker-compose-base.yaml</span><br><span class="line">        service: peer0.org1.example.com</span><br><span class="line">  </span><br><span class="line">    peer1.org1.example.com:</span><br><span class="line">      container_name: peer1.org1.example.com</span><br><span class="line">      extends:</span><br><span class="line">        file:  base/docker-compose-base.yaml</span><br><span class="line">        service: peer1.org1.example.com</span><br><span class="line">  </span><br><span class="line">    peer0.org2.example.com:</span><br><span class="line">      container_name: peer0.org2.example.com</span><br><span class="line">      extends:</span><br><span class="line">        file:  base/docker-compose-base.yaml</span><br><span class="line">        service: peer0.org2.example.com</span><br><span class="line">  </span><br><span class="line">    peer1.org2.example.com:</span><br><span class="line">      container_name: peer1.org2.example.com</span><br><span class="line">      extends:</span><br><span class="line">        file:  base/docker-compose-base.yaml</span><br><span class="line">        service: peer1.org2.example.com</span><br><span class="line">  </span><br><span class="line">    cli:</span><br><span class="line">      container_name: cli</span><br><span class="line">      image: hyperledger/fabric-tools</span><br><span class="line">      tty: <span class="literal">true</span></span><br><span class="line">      environment:</span><br><span class="line">        - GOPATH=/opt/gopath</span><br><span class="line">        - CORE_VM_ENDPOINT=unix:<span class="comment">///host/var/run/docker.sock</span></span><br><span class="line">        - CORE_LOGGING_LEVEL=DEBUG</span><br><span class="line">        - CORE_PEER_ID=cli</span><br><span class="line">        - CORE_PEER_ADDRESS=peer0.org1.example.com:<span class="number">7051</span></span><br><span class="line">        - CORE_PEER_LOCALMSPID=Org1MSP</span><br><span class="line">        - CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span><br><span class="line">        - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span><br><span class="line">        - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span><br><span class="line">        - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">        - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">      working_dir:/opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line">      command: /bin/bash -c <span class="string">'./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT'</span></span><br><span class="line">      volumes:</span><br><span class="line">          - /<span class="keyword">var</span>/run/:/host/<span class="keyword">var</span>/run/</span><br><span class="line">          - ../chaincode/<span class="keyword">go</span>/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/<span class="keyword">go</span></span><br><span class="line">          - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span><br><span class="line">          - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span><br><span class="line">          - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span><br><span class="line">      depends_on:</span><br><span class="line">        - orderer.example.com</span><br><span class="line">        - peer0.org1.example.com</span><br><span class="line">        - peer1.org1.example.com</span><br><span class="line">        - peer0.org2.example.com</span><br><span class="line">        - peer1.org2.example.com</span><br></pre></td></tr></table></figure><p>下面就来解读一下network_setup.sh脚本做了什么, 脚本内容如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">   #</span><br><span class="line">   # Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">   #</span><br><span class="line">   # SPDX-License-Identifier: Apache<span class="number">-2.0</span></span><br><span class="line">   #</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   UP_DOWN=<span class="string">"$1"</span></span><br><span class="line">   CH_NAME=<span class="string">"$2"</span></span><br><span class="line">   CLI_TIMEOUT=<span class="string">"$3"</span></span><br><span class="line">   IF_COUCHDB=<span class="string">"$4"</span></span><br><span class="line">   </span><br><span class="line">   : $&#123;CLI_TIMEOUT:=<span class="string">"10000"</span>&#125;</span><br><span class="line">   </span><br><span class="line">   COMPOSE_FILE=docker-compose-cli.yaml</span><br><span class="line">   COMPOSE_FILE_COUCH=docker-compose-couch.yaml</span><br><span class="line">   #COMPOSE_FILE=docker-compose-e2e.yaml</span><br><span class="line">   </span><br><span class="line">   function printHelp () &#123;</span><br><span class="line">   echo <span class="string">"Usage: ./network_setup &lt;up|down&gt; &lt;\$channel-name&gt; &lt;\$cli_timeout&gt; &lt;couchdb&gt;.\nThe arguments must be in order."</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function validateArgs () &#123;</span><br><span class="line">   <span class="keyword">if</span> [ -z <span class="string">"$&#123;UP_DOWN&#125;"</span> ]; then</span><br><span class="line">   echo <span class="string">"Option up / down / restart not mentioned"</span></span><br><span class="line">   printHelp</span><br><span class="line">   exit <span class="number">1</span></span><br><span class="line">   fi</span><br><span class="line">   <span class="keyword">if</span> [ -z <span class="string">"$&#123;CH_NAME&#125;"</span> ]; then</span><br><span class="line">   echo <span class="string">"setting to default channel 'mychannel'"</span></span><br><span class="line">   CH_NAME=mychannel</span><br><span class="line">   fi</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function clearContainers () &#123;</span><br><span class="line">           CONTAINER_IDS=$(docker ps -aq)</span><br><span class="line">           <span class="keyword">if</span> [ -z <span class="string">"$CONTAINER_IDS"</span> -o <span class="string">"$CONTAINER_IDS"</span> = <span class="string">" "</span> ]; then</span><br><span class="line">                   echo <span class="string">"---- No containers available for deletion ----"</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                   docker rm -f $CONTAINER_IDS</span><br><span class="line">           fi</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function removeUnwantedImages() &#123;</span><br><span class="line">           DOCKER_IMAGE_IDS=$(docker images | grep <span class="string">"dev\|none\|test-vp\|peer[0-9]-"</span> | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br><span class="line">           <span class="keyword">if</span> [ -z <span class="string">"$DOCKER_IMAGE_IDS"</span> -o <span class="string">"$DOCKER_IMAGE_IDS"</span> = <span class="string">" "</span> ]; then</span><br><span class="line">                   echo <span class="string">"---- No images available for deletion ----"</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                   docker rmi -f $DOCKER_IMAGE_IDS</span><br><span class="line">           fi</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function networkUp () &#123;</span><br><span class="line">       <span class="keyword">if</span> [ -f <span class="string">"./crypto-config"</span> ]; then</span><br><span class="line">         echo <span class="string">"crypto-config directory already exists."</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         #Generate all the artifacts that includes org certs, orderer genesis block,</span><br><span class="line">         # channel configuration transaction</span><br><span class="line">         source generateArtifacts.sh $CH_NAME</span><br><span class="line">       fi</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> [ <span class="string">"$&#123;IF_COUCHDB&#125;"</span> == <span class="string">"couchdb"</span> ]; then</span><br><span class="line">         CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE -f $COMPOSE_FILE_COUCH up -d <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">       fi</span><br><span class="line">       <span class="keyword">if</span> [ $? -ne <span class="number">0</span> ]; then</span><br><span class="line">   echo <span class="string">"ERROR !!!! Unable to pull the images "</span></span><br><span class="line">   exit <span class="number">1</span></span><br><span class="line">       fi</span><br><span class="line">       docker logs -f cli</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function networkDown () &#123;</span><br><span class="line">       docker-compose -f $COMPOSE_FILE down</span><br><span class="line">   </span><br><span class="line">       #Cleanup the chaincode containers</span><br><span class="line">       clearContainers</span><br><span class="line">   </span><br><span class="line">       #Cleanup images</span><br><span class="line">       removeUnwantedImages</span><br><span class="line">   </span><br><span class="line">       # remove orderer block and other channel configuration transactions and certs</span><br><span class="line">       rm -rf channel-artifacts<span class="comment">/*.block channel-artifacts/*.tx crypto-config</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   validateArgs</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   #Create the network using docker compose</span></span><br><span class="line"><span class="comment">   if [ "$&#123;UP_DOWN&#125;" == "up" ]; then</span></span><br><span class="line"><span class="comment">   networkUp</span></span><br><span class="line"><span class="comment">   elif [ "$&#123;UP_DOWN&#125;" == "down" ]; then ## Clear the network</span></span><br><span class="line"><span class="comment">   networkDown</span></span><br><span class="line"><span class="comment">   elif [ "$&#123;UP_DOWN&#125;" == "restart" ]; then ## Restart the network</span></span><br><span class="line"><span class="comment">   networkDown</span></span><br><span class="line"><span class="comment">   networkUp</span></span><br><span class="line"><span class="comment">   else</span></span><br><span class="line"><span class="comment">   printHelp</span></span><br><span class="line"><span class="comment">   exit 1</span></span><br><span class="line"><span class="comment">   fi</span></span><br></pre></td></tr></table></figure></p><h2 id="目前存在的一些问题以及解决办法"><a href="#目前存在的一些问题以及解决办法" class="headerlink" title="目前存在的一些问题以及解决办法"></a>目前存在的一些问题以及解决办法</h2><p>传统的比特币的交易网络最为人诟病的一点便是交易性能：全网每秒 7 笔的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认导致约 1 个小时的最终确认时间。</p><p>闪电网络提出的思路十分简单</p><p>将大量交易放到比特币区块链之外进行。该设计最早是 2015 年 2 月在论文《The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments》 中提出。 比特币的区块链机制自身提供了很好的可信保障，但是很慢；另一方面考虑，对于大量的小额交易来说，是否真实需要这么高的可信性？闪电网络通过智能合约来完善链下的交易渠道。</p><p>核心的概念主要有两个：RSMC（Recoverable Sequence Maturity Contract） 和 HTLC（Hashed TimelockContract）。前者解决了链下交易的确认问题，后者解决了支付通道的问题。</p><h3 id="RSMC"><a href="#RSMC" class="headerlink" title="RSMC"></a>RSMC</h3><p>Recoverable Sequence Maturity Contract，中文可以翻译为“可撤销的顺序成熟度合同”。主要原理类似准备金机制。 我们先假定交易双方之间存在一个“微支付通道”（资金池）。双方都预存一部分资金到“微支付通道”里，之后每次交易，就对交易后的资金分配方案共同进行确认，同时签字作废旧的版本。当需要提现时，将最终交易结果写到区块链网络中，被最终确认。可以看到，只有在提现时候才需要通过区块链。</p><p>任何一个版本的方案都需要经过双方的签名认证才合法。任何一方在任何时候都可以提出提 现，提现需要提供一个双方都签名过的资金分配方案（意味着肯定是某次交易后的结果） 。 在一定时间内，如果另外一方提出证明表明这个方案其实之前被作废了（非最新的交易结 果） ，则资金罚没给质疑成功方。这就确保了没人会拿一个旧的交易结果来提现。 另外，即使双方都确认了某次提现，首先提出提现一方的资金到账时间要晚于对方，这就鼓 励大家尽量都在链外完成交易。</p><h3 id="HTLC"><a href="#HTLC" class="headerlink" title="HTLC"></a>HTLC</h3><p>微支付通道是通过 Hashed Timelock Contract 来实现的，中文意思是“哈希的带时钟的合约”。这个其实就是限时转账。理解起来其实也很简单，通过智能合约，双方约定转账方先冻结一笔钱，并提供一个哈希值，如果在一定时间内有人能提出一个字符串，使得它哈希后的值跟已知值匹配（实际上意味着转账方授权了接收方来提现） ，则这笔钱转给接收方。</p><p>进一步推广，甲想转账给丙，丙先发给甲一个哈希值。甲可以跟先乙签订一个合同，如果你在 一定时间内能告诉我一个暗语，我就给你多少钱。乙于是跑去跟丙签订一个合同，如果你告 诉我那个暗语，我就给你多少钱。丙于是告诉乙暗语，拿到乙的钱，乙又从甲拿到钱。最终 达到结果是甲转账给丙。这样甲和丙之间似乎构成了一条完整的虚拟的“支付通道”。</p><p>HTLC 的机制可以扩展到多个人。</p><p>RSMC 保障了两个人之间的直接交易可以在链下完。</p><p>HTLC 保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。</p><p>整合这两种机制，就可以实现任意两个人之间的交易都可以在链下完成了。 在整个交易中，智能合约起到了中介的重要角色，而区块链则确保最终的交易结果被确认。</p><p>Fabric主要还是运行在容器上，但目前容器在测试环境有用，但据说生产环境用的比较少，容器的生命周期不太便于管理，也没有很好的稳定性。但最近阿里好像开源了一个自研的容器技术Pouch，还没看过。暂时不知道会带来什么样的影响。</p><p>此外由于Fabric相对比较新，学习资料，参考文档这些还比较少，又是基于分布式来运行，开发调试起来确实会比较困难。本身又是用Go写的，Go的项目管理工具又没有那么成熟，有时候你想导个包都要折腾半天。开发工具也参差不齐，目前感觉还没遇到完美的开发工至于为什么没有用java来讲，感觉没必要，具，都是几个混起来用，心累。</p><p>本身Fabric就是用Go写的，也是基于容器，而容器技术本身也是用Go来写的，所以有一个原生的go-dockerclient,可以在fabric-release\core\container\dockercontroller\中的dockercontroller.go中的import包里可以找到。此外Fabric中用到的corba和viper都可以研究一下，在Fabric中用到的确实很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;怎么基于开源区块链项目Hyperledger-fabric进行简单应用&quot;&gt;&lt;a href=&quot;#怎么基于开源区块链项目Hyperledger-fabric进行简单应用&quot; class=&quot;headerlink&quot; title=&quot;怎么基于开源区块链项目Hyperledger
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="区块链" scheme="https://yuzhen-li.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="fabric" scheme="https://yuzhen-li.github.io/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>用Python从零开始创建区块链</title>
    <link href="https://yuzhen-li.github.io/2018/05/13/%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://yuzhen-li.github.io/2018/05/13/用Python从零开始创建区块链/</id>
    <published>2018-05-13T09:07:53.000Z</published>
    <updated>2018-05-13T09:24:21.413Z</updated>
    
    <content type="html"><![CDATA[<p>作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。如果你还不是很了解哈希，可以百度相关知识。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>环境准备，确保已经安装Python3.6+, pip , Flask, requests<br>安装方法：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask==<span class="number">0.12</span><span class="number">.2</span> requests==<span class="number">2.18</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p><p>同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端.</p><p>请参考<a href="https://github.com/xilibi2003/blockchain.git" target="_blank" rel="noopener">源代码</a></p><h2 id="开始创建Blockchain"><a href="#开始创建Blockchain" class="headerlink" title="开始创建Blockchain"></a>开始创建Blockchain</h2><p>新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考<a href="https://github.com/xilibi2003/blockchain.git" target="_blank" rel="noopener">源代码</a></p><h3 id="Blockchain类"><a href="#Blockchain类" class="headerlink" title="Blockchain类"></a>Blockchain类</h3><p>首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。</p><p>以下是Blockchain类的框架：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.chain = []</span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Creates a new Block and adds it to the chain</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Adds a new transaction to the list of transactions</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod #声明了一个静态方法，不用实例化就可以调用该方法，可以直接类名调用方法，当然也可以实例化后再调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(block)</span>:</span></span><br><span class="line">        <span class="comment"># Hashes a Block</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property </span></span><br><span class="line"><span class="comment">#@property使方法像属性一样调用，就像是一种特殊的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Returns the last Block in the chain</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。</p><h2 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h2><p>每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。</p><p>以下是一个区块的结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">block = &#123;</span><br><span class="line">    <span class="string">'index'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'timestamp'</span>: <span class="number">1506057125.900785</span>,</span><br><span class="line">    <span class="string">'transactions'</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'sender'</span>: <span class="string">"8527147fe1f5426f9dd545de4b27ee00"</span>,</span><br><span class="line">            <span class="string">'recipient'</span>: <span class="string">"a77f5cdfa2934df3954a5c7c7da5df1f"</span>,</span><br><span class="line">            <span class="string">'amount'</span>: <span class="number">5</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'proof'</span>: <span class="number">324984774000</span>,</span><br><span class="line">    <span class="string">'previous_hash'</span>: <span class="string">"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化.</p><h2 id="加入交易"><a href="#加入交易" class="headerlink" title="加入交易"></a>加入交易</h2><p>接下来我们需要添加一个交易，来完善下new_transaction方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">(self, sender, recipient, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成新交易信息，信息将加入到下一个待挖的区块中</span></span><br><span class="line"><span class="string">        :param sender: &lt;str&gt; Address of the Sender</span></span><br><span class="line"><span class="string">        :param recipient: &lt;str&gt; Address of the Recipient</span></span><br><span class="line"><span class="string">        :param amount: &lt;int&gt; Amount</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            <span class="string">'sender'</span>: sender,</span><br><span class="line">            <span class="string">'recipient'</span>: recipient,</span><br><span class="line">            <span class="string">'amount'</span>: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_block[<span class="string">'index'</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。</p><h2 id="创建新块"><a href="#创建新块" class="headerlink" title="创建新块"></a>创建新块</h2><p>当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。</p><p>为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        self.chain = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create the genesis block 创世块</span></span><br><span class="line">        self.new_block(previous_hash=<span class="number">1</span>, proof=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_block</span><span class="params">(self, proof, previous_hash=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成新块</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm</span></span><br><span class="line"><span class="string">        :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block</span></span><br><span class="line"><span class="string">        :return: &lt;dict&gt; New Block</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">'index'</span>: len(self.chain) + <span class="number">1</span>,</span><br><span class="line">            <span class="string">'timestamp'</span>: time(),</span><br><span class="line">            <span class="string">'transactions'</span>: self.current_transactions,</span><br><span class="line">            <span class="string">'proof'</span>: proof,</span><br><span class="line">            <span class="string">'previous_hash'</span>: previous_hash <span class="keyword">or</span> self.hash(self.chain[<span class="number">-1</span>]),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset the current list of transactions</span></span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">        self.chain.append(block)</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">(self, sender, recipient, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成新交易信息，信息将加入到下一个待挖的区块中</span></span><br><span class="line"><span class="string">        :param sender: &lt;str&gt; Address of the Sender</span></span><br><span class="line"><span class="string">        :param recipient: &lt;str&gt; Address of the Recipient</span></span><br><span class="line"><span class="string">        :param amount: &lt;int&gt; Amount</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            <span class="string">'sender'</span>: sender,</span><br><span class="line">            <span class="string">'recipient'</span>: recipient,</span><br><span class="line">            <span class="string">'amount'</span>: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_block[<span class="string">'index'</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.chain[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(block)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成块的 SHA-256 hash值</span></span><br><span class="line"><span class="string">        :param block: &lt;dict&gt; Block</span></span><br><span class="line"><span class="string">        :return: &lt;str&gt;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes</span></span><br><span class="line">        block_string = json.dumps(block, sort_keys=<span class="keyword">True</span>).encode()</span><br><span class="line">        <span class="keyword">return</span> hashlib.sha256(block_string).hexdigest()</span><br></pre></td></tr></table></figure></p><p>通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。</p><h2 id="理解工作量证明"><a href="#理解工作量证明" class="headerlink" title="理解工作量证明"></a>理解工作量证明</h2><p>新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。</p><p>为了方便理解，举个例子：</p><p>假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？</p><p>用Python实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">0</span>  <span class="comment"># y未知</span></span><br><span class="line"><span class="keyword">while</span> sha256(<span class="string">f'<span class="subst">&#123;x*y&#125;</span>'</span>.encode()).hexdigest()[<span class="number">-1</span>] != <span class="string">"0"</span>:</span><br><span class="line">    y += <span class="number">1</span></span><br><span class="line">print(<span class="string">f'The solution is y = <span class="subst">&#123;y&#125;</span>'</span>)</span><br></pre></td></tr></table></figure></p><p>结果是y=21. 因为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="number">5</span> * <span class="number">21</span>) = <span class="number">1253e9373</span>e..<span class="number">.5e3600155</span>e860</span><br></pre></td></tr></table></figure></p><p>在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。</p><h2 id="实现工作量证明"><a href="#实现工作量证明" class="headerlink" title="实现工作量证明"></a>实现工作量证明</h2><p>让我们来实现一个相似PoW算法，规则是：寻找一个数p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">(self, last_proof)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        简单的工作量证明:</span></span><br><span class="line"><span class="string">         - 查找一个 p' 使得 hash(pp') 以4个0开头</span></span><br><span class="line"><span class="string">         - p 是上一个块的证明,  p' 是当前的证明</span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt;</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        proof = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> self.valid_proof(last_proof, proof) <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">            proof += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proof</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid_proof</span><span class="params">(last_proof, proof)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        验证证明: 是否hash(last_proof, proof)以4个0开头?</span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt; Previous Proof</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; Current Proof</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if correct, False if not.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="string">f'<span class="subst">&#123;last_proof&#125;</span><span class="subst">&#123;proof&#125;</span>'</span>.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        <span class="keyword">return</span> guess_hash[:<span class="number">4</span>] == <span class="string">"0000"</span></span><br></pre></td></tr></table></figure></p><p>衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。</p><p>现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。</p><h2 id="Blockchain作为API接口"><a href="#Blockchain作为API接口" class="headerlink" title="Blockchain作为API接口"></a>Blockchain作为API接口</h2><p>我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。</p><p>我们将创建三个接口：</p><pre><code>/transactions/new 创建一个交易并添加到区块/mine 告诉服务器去挖掘新的区块/chain 返回整个区块链</code></pre><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate our Node</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a globally unique address for this node</span></span><br><span class="line">node_identifier = str(uuid4()).replace(<span class="string">'-'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate the Blockchain</span></span><br><span class="line">blockchain = Blockchain()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/mine', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"We'll mine a new Block"</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.route('/transactions/new', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"We'll add a new transaction"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/chain', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_chain</span><span class="params">()</span>:</span></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'chain'</span>: blockchain.chain,</span><br><span class="line">        <span class="string">'length'</span>: len(blockchain.chain),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure></p><h2 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h2><p>发送到节点的交易数据结构如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"sender"</span>: <span class="string">"my address"</span>,</span><br><span class="line"> <span class="string">"recipient"</span>: <span class="string">"someone else's address"</span>,</span><br><span class="line"> <span class="string">"amount"</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之前已经有添加交易的方法，基于接口来添加交易就很简单了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/transactions/new', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_transaction</span><span class="params">()</span>:</span></span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check that the required fields are in the POST'ed data</span></span><br><span class="line">    required = [<span class="string">'sender'</span>, <span class="string">'recipient'</span>, <span class="string">'amount'</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> all(k <span class="keyword">in</span> values <span class="keyword">for</span> k <span class="keyword">in</span> required):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Missing values'</span>, <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a new Transaction</span></span><br><span class="line">    index = blockchain.new_transaction(values[<span class="string">'sender'</span>], values[<span class="string">'recipient'</span>], values[<span class="string">'amount'</span>])</span><br><span class="line"></span><br><span class="line">    response = &#123;<span class="string">'message'</span>: <span class="string">f'Transaction will be added to Block <span class="subst">&#123;index&#125;</span>'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">201</span></span><br></pre></td></tr></table></figure></p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>挖矿正是神奇所在，它很简单，做了一下三件事：</p><ul><li>计算工作量证明PoW</li><li>通过新增一个交易授予矿工（自己）一个币</li><li>构造新区块并将其添加到链中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4<span class="comment">#128位的全局唯一标识符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/mine', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># We run the proof of work algorithm to get the next proof...</span></span><br><span class="line">    last_block = blockchain.last_block</span><br><span class="line">    last_proof = last_block[<span class="string">'proof'</span>]</span><br><span class="line">    proof = blockchain.proof_of_work(last_proof)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给工作量证明的节点提供奖励.</span></span><br><span class="line">    <span class="comment"># 发送者为 "0" 表明是新挖出的币</span></span><br><span class="line">    blockchain.new_transaction(</span><br><span class="line">        sender=<span class="string">"0"</span>,</span><br><span class="line">        recipient=node_identifier,</span><br><span class="line">        amount=<span class="number">1</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forge the new Block by adding it to the chain</span></span><br><span class="line">    block = blockchain.new_block(proof)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'message'</span>: <span class="string">"New Block Forged"</span>,</span><br><span class="line">        <span class="string">'index'</span>: block[<span class="string">'index'</span>],</span><br><span class="line">        <span class="string">'transactions'</span>: block[<span class="string">'transactions'</span>],</span><br><span class="line">        <span class="string">'proof'</span>: block[<span class="string">'proof'</span>],</span><br><span class="line">        <span class="string">'previous_hash'</span>: block[<span class="string">'previous_hash'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br></pre></td></tr></table></figure></li></ul><p>注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下</p><h2 id="运行区块链"><a href="#运行区块链" class="headerlink" title="运行区块链"></a>运行区块链</h2><p>你可以使用cURL 或Postman 去和API进行交互</p><p>启动server:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python blockchain.py</span><br><span class="line">* Runing on http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure></p><p>让我们通过请求 <a href="http://localhost:5000/mine" target="_blank" rel="noopener">http://localhost:5000/mine</a> 来进行挖矿<br><img src="/assets/img/1.png" alt="图片"><br><img src="/assets/img/2.png" alt="图片"><br>如果不是使用Postman，则用一下的cURL语句也是一样的：<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H <span class="string">"Content-Type: application/json"</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string"> "</span>sender<span class="string">": "</span>d4ee26eee15148ee92c6cd394edd974e<span class="string">",</span></span><br><span class="line"><span class="string"> "</span>recipient<span class="string">": "</span>someone-other-address<span class="string">",</span></span><br><span class="line"><span class="string"> "</span>amount<span class="string">": 5</span></span><br><span class="line"><span class="string">&#125;'</span> <span class="string">"http://localhost:5000/transactions/new"</span></span><br></pre></td></tr></table></figure></p><p>在挖了两次矿之后，就有3个块了，通过请求 <a href="http://localhost:5000/chain" target="_blank" rel="noopener">http://localhost:5000/chain</a> 可以得到所有的块信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"chain"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"index"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"previous_hash"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"proof"</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="number">1506280650.770839</span>,</span><br><span class="line">      <span class="string">"transactions"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"index"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"previous_hash"</span>: <span class="string">"c099bc...bfb7"</span>,</span><br><span class="line">      <span class="string">"proof"</span>: <span class="number">35293</span>,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="number">1506280664.717925</span>,</span><br><span class="line">      <span class="string">"transactions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"amount"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"recipient"</span>: <span class="string">"8bbcb347e0634905b0cac7955bae152b"</span>,</span><br><span class="line">          <span class="string">"sender"</span>: <span class="string">"0"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"index"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">"previous_hash"</span>: <span class="string">"eff91a...10f2"</span>,</span><br><span class="line">      <span class="string">"proof"</span>: <span class="number">35089</span>,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="number">1506280666.1086972</span>,</span><br><span class="line">      <span class="string">"transactions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"amount"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"recipient"</span>: <span class="string">"8bbcb347e0634905b0cac7955bae152b"</span>,</span><br><span class="line">          <span class="string">"sender"</span>: <span class="string">"0"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"length"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一致性（共识）"><a href="#一致性（共识）" class="headerlink" title="一致性（共识）"></a>一致性（共识）</h2><p>我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。</p><h3 id="注册节点"><a href="#注册节点" class="headerlink" title="注册节点"></a>注册节点</h3><p>在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口：</p><ol><li>/nodes/register 接收URL形式的新节点列表</li><li>/nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链</li></ol><p>我们修改下Blockchain的init函数并提供一个注册节点方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self.nodes = set()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_node</span><span class="params">(self, address)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a new node to the list of nodes</span></span><br><span class="line"><span class="string">        :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000'</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        parsed_url = urlparse(address)<span class="comment">#用于解析url中的参数  对url按照一定格式进行 拆分或拼接</span></span><br><span class="line">        self.nodes.add(parsed_url.netloc)<span class="comment">#netloc 是域名服务器</span></span><br></pre></td></tr></table></figure></p><p>我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。</p><h3 id="实现共识算法"><a href="#实现共识算法" class="headerlink" title="实现共识算法"></a>实现共识算法</h3><p>前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。</p><p>我们使用以下的算法，来达到网络中的共识<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">valid_chain</span><span class="params">(self, chain)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Determine if a given blockchain is valid</span></span><br><span class="line"><span class="string">        :param chain: &lt;list&gt; A blockchain</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if valid, False if not</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        last_block = chain[<span class="number">0</span>]</span><br><span class="line">        current_index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current_index &lt; len(chain):</span><br><span class="line">            block = chain[current_index]</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;last_block&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;block&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">"\n-----------\n"</span>)</span><br><span class="line">            <span class="comment"># Check that the hash of the block is correct</span></span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">'previous_hash'</span>] != self.hash(last_block):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check that the Proof of Work is correct</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.valid_proof(last_block[<span class="string">'proof'</span>], block[<span class="string">'proof'</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            last_block = block</span><br><span class="line">            current_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolve_conflicts</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        共识算法解决冲突</span></span><br><span class="line"><span class="string">        使用网络中最长的链.</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True 如果链被取代, 否则为False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        neighbours = self.nodes</span><br><span class="line">        new_chain = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We're only looking for chains longer than ours</span></span><br><span class="line">        max_length = len(self.chain)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Grab and verify the chains from all the nodes in our network</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> neighbours:</span><br><span class="line">            response = requests.get(<span class="string">f'http://<span class="subst">&#123;node&#125;</span>/chain'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                length = response.json()[<span class="string">'length'</span>]</span><br><span class="line">                chain = response.json()[<span class="string">'chain'</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check if the length is longer and the chain is valid</span></span><br><span class="line">                <span class="keyword">if</span> length &gt; max_length <span class="keyword">and</span> self.valid_chain(chain):</span><br><span class="line">                    max_length = length</span><br><span class="line">                    new_chain = chain</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Replace our chain if we discovered a new, valid chain longer than ours</span></span><br><span class="line">        <span class="keyword">if</span> new_chain:</span><br><span class="line">            self.chain = new_chain</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof.</p><p>第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链;就是比较每个节点（服务器）上的最长有效链。<br>让我们添加两个路由，一个用来注册节点，一个用来解决冲突。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/nodes/register', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_nodes</span><span class="params">()</span>:</span></span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    nodes = values.get(<span class="string">'nodes'</span>)</span><br><span class="line">    <span class="keyword">if</span> nodes <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Error: Please supply a valid list of nodes"</span>, <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        blockchain.register_node(node)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'message'</span>: <span class="string">'New nodes have been added'</span>,</span><br><span class="line">        <span class="string">'total_nodes'</span>: list(blockchain.nodes),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/nodes/resolve', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consensus</span><span class="params">()</span>:</span></span><br><span class="line">    replaced = blockchain.resolve_conflicts()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> replaced:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'message'</span>: <span class="string">'Our chain was replaced'</span>,</span><br><span class="line">            <span class="string">'new_chain'</span>: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'message'</span>: <span class="string">'Our chain is authoritative'</span>,</span><br><span class="line">            <span class="string">'chain'</span>: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br></pre></td></tr></table></figure></p><p>你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：<a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> 和 <a href="http://localhost:5001" target="_blank" rel="noopener">http://localhost:5001</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipenv run python blockchain.py</span><br><span class="line">pipenv run python blockchain.py -p <span class="number">5001</span></span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/3.png" alt="图片"><br>然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。<br><img src="/assets/img/4.png" alt="图片"><br>好啦，你可以邀请朋友们一起来测试你的区块链!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="区块链" scheme="https://yuzhen-li.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Python" scheme="https://yuzhen-li.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器之@property</title>
    <link href="https://yuzhen-li.github.io/2018/05/10/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B9%8B@property/"/>
    <id>https://yuzhen-li.github.io/2018/05/10/Python装饰器之@property/</id>
    <published>2018-05-10T07:39:12.000Z</published>
    <updated>2018-05-10T07:42:24.302Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line">考察 Student 类：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">当我们想要修改一个 Student 的 scroe 属性时，可以这么写：</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line">但是也可以这么写：</span><br><span class="line"></span><br><span class="line">s.score = <span class="number">1000</span></span><br><span class="line">显然，直接给属性赋值无法检查分数的有效性。</span><br><span class="line"></span><br><span class="line">如果利用两个方法：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        self.__score = score</span><br><span class="line">这样一来，s.set_score(<span class="number">1000</span>) 就会报错。</span><br><span class="line"></span><br><span class="line">这种使用 get/set 方法来封装对一个属性的访问在许多面向对象编程的语言中都很常见。</span><br><span class="line"></span><br><span class="line">但是写 s.get_score() 和 s.set_score() 没有直接写 s.score 来得直接。</span><br><span class="line"></span><br><span class="line">有没有两全其美的方法？----有。</span><br><span class="line"></span><br><span class="line">因为Python支持高阶函数，在函数式编程中我们介绍了装饰器函数，可以用装饰器函数把 get/set 方法“装饰”成属性调用：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        self.__score = score</span><br><span class="line">注意: 第一个score(self)是get方法，用@property装饰，第二个score(self, score)是set方法，用@score.setter装饰，@score.setter是前一个@property装饰后的副产品。</span><br><span class="line"></span><br><span class="line">现在，就可以像使用属性一样设置score了：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s.score</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">1000</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: invalid score</span><br><span class="line">说明对 score 赋值实际调用的是 set方法。</span><br><span class="line"></span><br><span class="line">任务</span><br><span class="line">如果没有定义set方法，就不能对“属性”赋值，这时，就可以创建一个只读“属性”。</span><br><span class="line"></span><br><span class="line">请给Student类加一个grade属性，根据 score 计算 A（&gt;=<span class="number">80</span>）、B、C（&lt;<span class="number">60</span>）。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="python" scheme="https://yuzhen-li.github.io/tags/python/"/>
    
      <category term="property" scheme="https://yuzhen-li.github.io/tags/property/"/>
    
      <category term="装饰器" scheme="https://yuzhen-li.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>这是一个测试</title>
    <link href="https://yuzhen-li.github.io/2018/04/17/test/"/>
    <id>https://yuzhen-li.github.io/2018/04/17/test/</id>
    <published>2018-04-17T09:56:11.000Z</published>
    <updated>2018-04-17T10:04:16.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试"><a href="#这是一个测试" class="headerlink" title="这是一个测试"></a>这是一个测试</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil, floor, log</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count  <span class="comment"># combinations, count, product</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">from</span> mapper.tools <span class="keyword">import</span> qhull, shortest_path, pdfwriter, graphviz_node_pos, dict_values</span><br><span class="line"></span><br><span class="line">mplversion = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> mpl.__version__.split(<span class="string">' '</span>)[<span class="number">0</span>].split(<span class="string">'.'</span>)[:<span class="number">2</span>]]</span><br><span class="line"><span class="keyword">if</span> mplversion &lt; [<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Warning: Best results are obtained with Matplotlib version at '</span></span><br><span class="line">           <span class="string">'least 1.0.\n'</span></span><br><span class="line">           <span class="string">'Python Mapper should work with Matplotlib 0.99, too, but some '</span></span><br><span class="line">           <span class="string">'features are\nmissing.'</span>)</span><br><span class="line"><span class="keyword">if</span> mplversion &lt; [<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">    <span class="comment"># Specification for a short horizontal line, 'hline'.</span></span><br><span class="line">    <span class="comment"># We cannot use the first specification universally since Matplotlib</span></span><br><span class="line">    <span class="comment"># changed the angle parameter from radians to degree in 1.1.0.</span></span><br><span class="line">    hlinemarkersymbol = (<span class="number">2</span>, <span class="number">2</span>, <span class="number">.5</span> * np.pi)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># (2,2,90) does work, too, but Matplotlib 1.1.0 knows the symbol '_'.</span></span><br><span class="line">    hlinemarkersymbol = <span class="string">'_'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这是一个测试&quot;&gt;&lt;a href=&quot;#这是一个测试&quot; class=&quot;headerlink&quot; title=&quot;这是一个测试&quot;&gt;&lt;/a&gt;这是一个测试&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="test" scheme="https://yuzhen-li.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>自然语言（分词、分词、实体识别等）集成投票算法实例</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%EF%BC%88%E5%88%86%E8%AF%8D%E3%80%81%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8%E3%80%81%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%E7%AD%89%EF%BC%89%E9%9B%86%E6%88%90%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/自然语言（分词、词性标注、实体识别等）集成投票算法实例/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-16T07:32:42.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源代码注释"><a href="#源代码注释" class="headerlink" title="源代码注释"></a>源代码注释</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#获取数字编号</span><br><span class="line">def numCode(s1_str):</span><br><span class="line">    #s1_str = <span class="string">'|'</span>.<span class="keyword">join</span>(s_str)</span><br><span class="line">    tempNum = <span class="number">1</span></span><br><span class="line">    saveNum = []</span><br><span class="line">    <span class="keyword">for</span> s1_s in s1_str:</span><br><span class="line">        <span class="keyword">if</span> s1_s != <span class="string">'/'</span>:</span><br><span class="line">            saveNum.<span class="keyword">append</span>(tempNum)</span><br><span class="line">        tempNum = tempNum + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> saveNum</span><br><span class="line">#三种分词方法进行融合</span><br><span class="line">def decisonThree(s,s1,s2,s3):</span><br><span class="line">    # s = [<span class="string">'我'</span>, <span class="string">'是'</span>, <span class="string">'招'</span>, <span class="string">'商'</span>, <span class="string">'银'</span>, <span class="string">'行'</span>, <span class="string">'的'</span>, <span class="string">'一'</span>, <span class="string">'员'</span>, <span class="string">'。'</span>]</span><br><span class="line">    # s1 = [<span class="string">'我'</span>, <span class="string">'是'</span>, <span class="string">'招商'</span>, <span class="string">'银行的'</span>, <span class="string">'一员。'</span>]</span><br><span class="line">    # s2 = [<span class="string">'我是'</span>, <span class="string">'招商'</span>, <span class="string">'银行'</span>, <span class="string">'的'</span>, <span class="string">'一员'</span>, <span class="string">'。'</span>]</span><br><span class="line">    # s3 = [<span class="string">'我'</span>, <span class="string">'是招'</span>, <span class="string">'商'</span>, <span class="string">'银行'</span>, <span class="string">'的'</span>, <span class="string">'一员'</span>, <span class="string">'。'</span>]</span><br><span class="line">    a1 = numCode(s1) #我爱你/，/桂/书品/！</span><br><span class="line">    b1 = numCode(s2) </span><br><span class="line">    c1 = numCode(s3)</span><br><span class="line">    <span class="keyword">print</span>(s)</span><br><span class="line">    <span class="keyword">print</span>(s1)#我爱你/，/桂/书品/！</span><br><span class="line">    <span class="keyword">print</span>(a1)#[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>]  遇到/，序号+<span class="number">1</span>，不添加到列表中</span><br><span class="line">    <span class="keyword">print</span>(s2)#我/爱/你/，/桂/书品/！</span><br><span class="line">    <span class="keyword">print</span>(b1)#[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">    <span class="keyword">print</span>(s3)#我/爱/你/，/桂/书品/！</span><br><span class="line">    <span class="keyword">print</span>(c1)#[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">    d1 = []</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(a1)):</span><br><span class="line">        <span class="keyword">if</span> ((a1[i] == b1[i]) <span class="built_in">and</span> (a1[i] == c1[i])):</span><br><span class="line">            d1.<span class="keyword">append</span>(a1[i])</span><br><span class="line">            # <span class="keyword">continue</span></span><br><span class="line">        elif a1[i] == b1[i]:</span><br><span class="line">            d1.<span class="keyword">append</span>(a1[i])</span><br><span class="line">            <span class="keyword">for</span> ii in <span class="built_in">range</span>((i + <span class="number">1</span>), <span class="built_in">len</span>(c1)):</span><br><span class="line">                <span class="keyword">if</span> a1[i] &lt; c1[i]:</span><br><span class="line">                    c1[ii] = c1[ii] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c1[ii] = c1[ii] + <span class="number">1</span></span><br><span class="line">        elif a1[i] == c1[i]:   ##投票算法的核心思想是如果其中两种的分词结果一样，则分词结果为票数多的分词结果。</span><br><span class="line">            d1.<span class="keyword">append</span>(a1[i])</span><br><span class="line">            <span class="keyword">for</span> ii in <span class="built_in">range</span>((i + <span class="number">1</span>), <span class="built_in">len</span>(b1)):</span><br><span class="line">                <span class="keyword">if</span> a1[i] &lt; b1[i]:</span><br><span class="line">                    b1[ii] = b1[ii] - <span class="number">1</span>###使不同的分词+<span class="number">1</span>或者-<span class="number">1</span>，从下一个位置开始比较。</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b1[ii] = b1[ii] + <span class="number">1</span></span><br><span class="line">        elif c1[i] == b1[i]:</span><br><span class="line">            d1.<span class="keyword">append</span>(b1[i])</span><br><span class="line">            <span class="keyword">for</span> ii in <span class="built_in">range</span>((i + <span class="number">1</span>), <span class="built_in">len</span>(a1)):</span><br><span class="line">                <span class="keyword">if</span> b1[i] &lt; a1[i]:</span><br><span class="line">                    a1[ii] = a1[ii] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a1[ii] = a1[ii] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span>(<span class="string">'Decision Fusion:'</span>)</span><br><span class="line">    <span class="keyword">print</span>(d1)#[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">    sumPos = <span class="number">0</span></span><br><span class="line">    listTemp = []</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">max</span>(d1)):</span><br><span class="line">        listTemp.<span class="keyword">append</span>(<span class="string">'|'</span>)</span><br><span class="line">    sNum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">print</span>(listTemp)#[<span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>, <span class="string">'|'</span>]，形成d1中数量最大的个数的<span class="string">'|'</span></span><br><span class="line">    <span class="keyword">for</span> nPos in d1:</span><br><span class="line">        listTemp[nPos - <span class="number">1</span>] = s[sNum]</span><br><span class="line">        sNum = sNum + <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span>(listTemp)#[<span class="string">'我'</span>, <span class="string">'|'</span>, <span class="string">'爱'</span>, <span class="string">'|'</span>, <span class="string">'你'</span>, <span class="string">'|'</span>, <span class="string">'，'</span>, <span class="string">'|'</span>, <span class="string">'桂'</span>, <span class="string">'|'</span>, <span class="string">'书'</span>, <span class="string">'品'</span>, <span class="string">'|'</span>, <span class="string">'！'</span>]把listTemp中<span class="string">'|'</span>通过d1的序号提换成s中的字符。</span><br><span class="line">    outputStr = <span class="string">''</span>.<span class="keyword">join</span>(listTemp)</span><br><span class="line">    outputStr = outputStr.<span class="keyword">split</span>(<span class="string">'|'</span>)</span><br><span class="line">    <span class="keyword">print</span>(outputStr)#[<span class="string">'我'</span>, <span class="string">'爱'</span>, <span class="string">'你'</span>, <span class="string">'，'</span>, <span class="string">'桂'</span>, <span class="string">'书品'</span>, <span class="string">'！'</span>]</span><br><span class="line">    <span class="keyword">return</span> outputStr</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;源代码注释&quot;&gt;&lt;a href=&quot;#源代码注释&quot; class=&quot;headerlink&quot; title=&quot;源代码注释&quot;&gt;&lt;/a&gt;源代码注释&lt;/h1&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="分词" scheme="https://yuzhen-li.github.io/tags/%E5%88%86%E8%AF%8D/"/>
    
      <category term="投票集成算法" scheme="https://yuzhen-li.github.io/tags/%E6%8A%95%E7%A5%A8%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理之spacy库</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%B9%8Bspacy%E5%BA%93/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/自然语言处理之spacy库/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-15T16:07:36.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Python-spaCy-进行简易自然语言处理"><a href="#使用-Python-spaCy-进行简易自然语言处理" class="headerlink" title="使用 Python+spaCy 进行简易自然语言处理"></a>使用 Python+spaCy 进行简易自然语言处理</h1><h2 id="spaCy-简介及安装方法"><a href="#spaCy-简介及安装方法" class="headerlink" title="spaCy 简介及安装方法"></a>spaCy 简介及安装方法</h2><p>安装和编译 spaCy 比较方便，在ubuntu环境下，直接用pip安装即可：</p><pre><code>sudo apt-get install build-essential python-dev gitsudo pip install -U spacy</code></pre><p>不过安装完毕之后，需要下载相关的模型数据，以英文模型数据为例，可以用”all”参数下载所有的数据:</p><pre><code>sudo python -m spacy.en.download all</code></pre><p>可能提示 no module named spacy.en</p><p>则执行：python -m spacy download en 即可</p><p>现在可以快速测试一下spaCy的相关功能，我们以英文数据为例，spaCy目前主要支持英文和德文，对其他语言的支持正在陆续加入：</p><pre><code># 加载英文模型数据，稍许等待In [2]: nlp = spacy.load(&apos;en&apos;)</code></pre><h2 id="分词："><a href="#分词：" class="headerlink" title="分词："></a>分词：</h2><pre><code>In [3]: test_doc = nlp(u&quot;it&apos;s word tokenize test for spacy&quot;)In [4]: print(test_doc)it&apos;s word tokenize test for spacyIn [5]: for token in test_doc:print(token)...:it&apos;swordtokenizetestforspacy英文断句:In [6]: test_doc = nlp(u&apos;Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.&apos;)In [7]: for sent in test_doc.sents:print(sent)...:Natural language processing (NLP) deals with the application of computational models to text or speech data.Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways.NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form.From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.</code></pre><h2 id="词性标注-POS-Tagging"><a href="#词性标注-POS-Tagging" class="headerlink" title="词性标注(POS Tagging):"></a>词性标注(POS Tagging):</h2><pre><code>In [10]: for token in test_doc:print(token, token.pos_, token.pos)....:(you, u&apos;PRON&apos;, 92)(are, u&apos;VERB&apos;, 97)(best, u&apos;ADJ&apos;, 82)(., u&apos;PUNCT&apos;, 94)(it, u&apos;PRON&apos;, 92)(is, u&apos;VERB&apos;, 97)(lemmatize, u&apos;ADJ&apos;, 82)(test, u&apos;NOUN&apos;, 89)(for, u&apos;ADP&apos;, 83)(spacy, u&apos;NOUN&apos;, 89)(., u&apos;PUNCT&apos;, 94)(I, u&apos;PRON&apos;, 92)(love, u&apos;VERB&apos;, 97)(these, u&apos;DET&apos;, 87)(books, u&apos;NOUN&apos;, 89)</code></pre><h2 id="命名实体识别（NER）："><a href="#命名实体识别（NER）：" class="headerlink" title="命名实体识别（NER）："></a>命名实体识别（NER）：</h2><pre><code>In [11]: test_doc = nlp(u&quot;Rami Eid is studying at Stony Brook University in New York&quot;)In [12]: for ent in test_doc.ents:print(ent, ent.label_, ent.label)....:(Rami Eid, u&apos;PERSON&apos;, 346)(Stony Brook University, u&apos;ORG&apos;, 349)(New York, u&apos;GPE&apos;, 350)</code></pre><p>代码统一整理：</p><pre><code>import spacynlp = spacy.load(&apos;en&apos;)test_doc = nlp(u&quot;it&apos;s word tokenize test for spacy&quot;)# 分词print(&quot;\n1、分词&quot;)print(test_doc)for token in test_doc:    print(token)# 分句print(&quot;\n2、分句&quot;)test_doc = nlp(u&apos;Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.&apos;)print(test_doc)for sent in test_doc.sents:    print(sent)# 词干化print(&quot;\n3、词干化&quot;)test_doc = nlp(u&quot;you are best. it is lemmatize test for spacy. I love these books&quot;)print(test_doc)for token in test_doc:    print(token, token.lemma_, token.lemma)# 词性标注print(&quot;\n4、词性标注&quot;)print(test_doc)for token in test_doc:    print(token, token.pos_, token.pos)# 命名实体识别print(&quot;\n5、命名实体识别&quot;)test_doc = nlp(u&quot;Rami Eid is studying at Stony Brook University in New York&quot;)print(test_doc)for ent in test_doc.ents:    print(ent, ent.label_, ent.label)# 名词短语提取print(&quot;\n6、名词短语提取&quot;)test_doc = nlp(u&apos;Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.&apos;)print(test_doc)for np in test_doc.noun_chunks:    print(np)# 基于词向量计算两个单词的相似度print(&quot;\n7、基于词向量计算两个单词的相似度&quot;)test_doc = nlp(u&quot;Apples and oranges are the same . Boots and hippos aren&apos;t.&quot;)print(test_doc)apples = test_doc[0]print(apples)oranges = test_doc[2]print(oranges)boots = test_doc[7]print(boots)hippos = test_doc[9]print(hippos)print(apples.similarity(oranges))print(boots.similarity(hippos))</code></pre><p>结果</p><pre><code>/usr/bin/python3.5 /home/wmmm/PycharmProjects/untitled/zstp.py1、分词it&apos;s word tokenize test for spacyit&apos;swordtokenizetestforspacy2、分句Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.Natural language processing (NLP) deals with the application of computational models to text or speech data.Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways.NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form.From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.3、词干化you are best. it is lemmatize test for spacy. I love these booksyou -PRON- 561228191312463089are be 10382539506755952630best good 5711639017775284443. . 12646065887601541794it -PRON- 561228191312463089is be 10382539506755952630lemmatize lemmatize 4507259281035238268test test 1618900948208871284for for 16037325823156266367spacy spacy 10639093010105930009. . 12646065887601541794I -PRON- 561228191312463089love love 3702023516439754181these these 6459564349623679250books book 138144331071114592974、词性标注you are best. it is lemmatize test for spacy. I love these booksyou PRON 94are VERB 99best ADJ 83. PUNCT 96it PRON 94is VERB 99lemmatize ADJ 83test NOUN 91for ADP 84spacy NOUN 91. PUNCT 96I PRON 94love VERB 99these DET 89books NOUN 915、命名实体识别Rami Eid is studying at Stony Brook University in New YorkRami Eid PERSON 378Stony Brook University ORG 381New York GPE 3826、名词短语提取Natural language processing (NLP) deals with the application of computational models to text or speech data. Application areas within NLP include automatic (machine) translation between languages; dialogue systems, which allow a human to interact with a machine using natural language; and information extraction, where the goal is to transform unstructured text into structured (database) representations that can be searched and browsed in flexible ways. NLP technologies are having a dramatic impact on the way people interact with computers, on the way people interact with each other through the use of language, and on the way people access the vast amount of linguistic data now in electronic form. From a scientific viewpoint, NLP involves fundamental questions of how to structure formal models (for example statistical models) of natural language phenomena, and of how to design algorithms that implement these models.Natural language processingthe applicationcomputational modelsApplication areasNLPautomatic (machine) translationlanguagesdialogue systemsa humana machinenatural languageinformation extractionthe goalunstructured textstructured (database) representationsflexible waysNLP technologiesa dramatic impactthe waypeoplecomputersthe waypeoplethe uselanguagethe waypeoplethe vast amountlinguistic dataelectronic forma scientific viewpointNLPfundamental questionsformal modelsexamplenatural language phenomenaalgorithmsthese models7、基于词向量计算两个单词的相似度Apples and oranges are the same . Boots and hippos aren&apos;t.ApplesorangesBootshippos0.5180960.158362进程已结束,退出代码0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-Python-spaCy-进行简易自然语言处理&quot;&gt;&lt;a href=&quot;#使用-Python-spaCy-进行简易自然语言处理&quot; class=&quot;headerlink&quot; title=&quot;使用 Python+spaCy 进行简易自然语言处理&quot;&gt;&lt;/a&gt;使用 Pytho
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="spacy" scheme="https://yuzhen-li.github.io/tags/spacy/"/>
    
  </entry>
  
  <entry>
    <title>NLP处理之polyglot</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/NLP%E5%A4%84%E7%90%86%E4%B9%8Bpolyglot/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/NLP处理之polyglot/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-16T08:33:53.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install polyglot</span></span><br></pre></td></tr></table></figure><p>安装依赖库</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install python-numpy libicu-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>在Python中import _icu（这个语句其实在polyglot安装成功后import polyglot.text是报错发现的）的时候，发现importerror …. _icu.so: no defined …(忘了)<br>所以我们这个动态链接库是没有build成功的。<br>可能是pip install的时候没有生成一个好的_icu.so<br>所以我们要在安装python模块的时候入手，icu4c模块应该没问题了。<br>编译安装成功<br>我就不用pip安装了，直接下源码</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://pypi.python.org/packages/bf/<span class="number">1</span>f/cea<span class="number">237</span>f<span class="number">542e3</span>bb<span class="number">592980008</span>a<span class="number">734850e8</span>cbbc<span class="number">25</span><span class="keyword">c</span><span class="number">19</span><span class="keyword">c</span><span class="number">72</span><span class="keyword">c</span><span class="number">98767</span><span class="keyword">c</span><span class="number">71</span><span class="keyword">c</span><span class="number">1</span>bd<span class="number">9</span><span class="keyword">c</span><span class="number">2</span>/PyICU<span class="number">-2.0</span>.<span class="number">3</span>.tar.gz</span><br><span class="line"># (去官网下载，我的是<span class="number">1.9</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">tar zxvf PyICU<span class="number">-2.0</span>.<span class="number">3</span>.tar.gz</span><br><span class="line">cd PyICU<span class="number">-2.0</span>.<span class="number">3</span>.tar.gz</span><br></pre></td></tr></table></figure><p>此时如果你是linux系统要修改一下setup.py文件<br>具体如下图所示</p><p><img src="/assets/blogImg/test1.jpg" alt="图1"><br><img src="/assets/blogImg/test2.jpg" alt="图2"></p><p>然后</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup<span class="selector-class">.py</span> build</span><br><span class="line">sudo python setup<span class="selector-class">.py</span> install</span><br></pre></td></tr></table></figure><h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from polyglot.text <span class="keyword">import</span> <span class="built_in">Text</span></span><br><span class="line"></span><br><span class="line">blob = <span class="string">u"""The baby eagle liked the nest. It was the only world he had ever known. It was warm and comfortable, had a great view, and even better, he had all the food and love and attention that a great mother eagle could provide"""</span></span><br><span class="line"></span><br><span class="line">text = <span class="built_in">Text</span>(blob)</span><br><span class="line"></span><br><span class="line">text.words</span><br></pre></td></tr></table></figure><h1 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h1><p>首先需要下载通用词性标签集</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">polyglot</span> <span class="selector-tag">download</span> <span class="selector-tag">embeddings2</span><span class="selector-class">.en</span> <span class="selector-tag">pos2</span><span class="selector-class">.en</span></span><br></pre></td></tr></table></figure><p>这一步要等好久好久，反正我等得是花都谢了，N次怀疑电脑卡死了。<br>词性标注具体代码如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from polyglot.text <span class="keyword">import</span> <span class="built_in">Text</span></span><br><span class="line"></span><br><span class="line">blob = <span class="string">"""We will meet at eight o'clock on Thursday morning."""</span></span><br><span class="line">text = <span class="built_in">Text</span>(blob)</span><br><span class="line"></span><br><span class="line">text.pos_tags</span><br></pre></td></tr></table></figure><h1 id="实体识别"><a href="#实体识别" class="headerlink" title="实体识别"></a>实体识别</h1><p>首先也要安装相关依赖包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">polyglot</span> <span class="selector-tag">download</span> <span class="selector-tag">embeddings2</span><span class="selector-class">.en</span> <span class="selector-tag">ner2</span><span class="selector-class">.en</span></span><br></pre></td></tr></table></figure><p>相关代码如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from polyglot.text <span class="keyword">import</span> <span class="built_in">Text</span></span><br><span class="line">blob = <span class="string">"""The Israeli Prime Minister Benjamin Netanyahu has warned that Iran poses a "threat to the entire world"."""</span></span><br><span class="line">text = <span class="built_in">Text</span>(blob)</span><br><span class="line"></span><br><span class="line">text.entities</span><br></pre></td></tr></table></figure><p>但是上面打印出来的结果不是字典的形式，为了最后成为字典，可以这样处理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nerL = [ ]</span><br><span class="line">nerR = &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> sent int text<span class="selector-class">.sentences</span>:</span><br><span class="line">    <span class="keyword">for</span> entity <span class="keyword">in</span> sent<span class="selector-class">.entities</span>:</span><br><span class="line">        nerL.append(entity)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter <span class="keyword">in</span> nerL:</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> iter:</span><br><span class="line">        nerR[i] = iter.tag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(R)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="polyglot" scheme="https://yuzhen-li.github.io/tags/polyglot/"/>
    
  </entry>
  
  <entry>
    <title>NLP的JSON格式输出</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/NLP%E7%9A%84JSON%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/NLP的JSON格式输出/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-16T09:18:24.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分词的JSON格式输出"><a href="#分词的JSON格式输出" class="headerlink" title="分词的JSON格式输出"></a>分词的JSON格式输出</h1><h2 id="实现核心"><a href="#实现核心" class="headerlink" title="实现核心"></a>实现核心</h2><p>实现的核心是构造 convertToJson(words)函数，首先需要将各种策略下的分词输出，转化成list输出。保证输入该函数的参数是list。该函数的具体代码如下：<br><figure class="highlight ruby"><figcaption><span>python:objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertToJson</span><span class="params">(words)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment">#the paramter words have been already segmented</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#词性标注功能</span></span><br><span class="line">    postagger = Postagger()  </span><br><span class="line">    postagger.load(<span class="string">"/models/pyltp/ltp_data_v3.4.0/pos.model"</span>)  </span><br><span class="line">    postags = postagger.postag(words) </span><br><span class="line">    postagger.release()  <span class="comment"># 释放模型 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果整合为json。这是重点。我把原代码的print全部注释。  </span></span><br><span class="line">    resultJson=[] <span class="comment">#创建一个空列表，用于保存json数据。  </span></span><br><span class="line">    length = len(words)</span><br><span class="line">    <span class="keyword">begin</span>= []</span><br><span class="line">    <span class="keyword">end</span> = []</span><br><span class="line">    <span class="keyword">begin</span>.append(<span class="number">0</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="symbol">length:</span></span><br><span class="line">         <span class="keyword">end</span>.append(<span class="keyword">begin</span>[i] + len(words[i]) - <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">if</span> i == length - <span class="number">1</span><span class="symbol">:</span></span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">         <span class="symbol">else:</span></span><br><span class="line">             <span class="keyword">begin</span>.append(<span class="keyword">begin</span>[i] + len(words[i]))</span><br><span class="line">         i=i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(words))<span class="symbol">:</span><span class="comment">#遍历结果  </span></span><br><span class="line">        resultJson.append(&#123;<span class="string">'id'</span><span class="symbol">:index</span>,<span class="string">'begin'</span><span class="symbol">:begin</span>[index],<span class="string">'end'</span><span class="symbol">:end</span>[index],<span class="string">'cont'</span><span class="symbol">:words</span>[index],<span class="string">'pos'</span><span class="symbol">:postags</span>[index]&#125;) <span class="comment">#将各功能的结果对应地添加到json中  </span></span><br><span class="line">    <span class="keyword">return</span> resultJson <span class="comment"># 返回函数结果  </span></span><br></pre></td></tr></table></figure></p><p>这个函数中用pyltp库实现了词性标注，而且标注了每个分词在原来句子中的位置。<br>最后通过一个大循环把所有的结果存到resultJson，最后可以应用dumps函数实现json格式转换。</p><pre><code>result=json.dumps({&apos;status&apos;:&apos;0&apos;,&apos;inputStr&apos;:inputStr,&apos;mode&apos;:methodNum,&apos;outputStr&apos;:finalResult},ensure_ascii=False,indent=2)</code></pre><h2 id="遇到的问题和解决方案"><a href="#遇到的问题和解决方案" class="headerlink" title="遇到的问题和解决方案"></a>遇到的问题和解决方案</h2><p>   在与前端联调的过程中出现问题，总是不同，有500的错误提出。消耗了我两天多的时间，最后发现问题是：前端发给我的数字都是字符串，而我在后面代码中的数字都是int型的，所以出问题。最后的解决办法是，将前端发过来的数字强制转换成int型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分词的JSON格式输出&quot;&gt;&lt;a href=&quot;#分词的JSON格式输出&quot; class=&quot;headerlink&quot; title=&quot;分词的JSON格式输出&quot;&gt;&lt;/a&gt;分词的JSON格式输出&lt;/h1&gt;&lt;h2 id=&quot;实现核心&quot;&gt;&lt;a href=&quot;#实现核心&quot; class=&quot;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="分词" scheme="https://yuzhen-li.github.io/tags/%E5%88%86%E8%AF%8D/"/>
    
      <category term="JSON" scheme="https://yuzhen-li.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理textblog安装使用</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86textblog%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/自然语言处理textblog安装使用/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-04-15T16:09:52.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自然语言处理-textblog-安装使用"><a href="#自然语言处理-textblog-安装使用" class="headerlink" title="自然语言处理 textblog 安装使用"></a>自然语言处理 textblog 安装使用</h1><h2 id="TextBlob是什么？"><a href="#TextBlob是什么？" class="headerlink" title="TextBlob是什么？"></a>TextBlob是什么？</h2><p>TextBlob是一个用Python编写的开源的文本处理库。它可以用来执行很多自然语言处理的任务，比如，词性标注，名词性成分提取，情感分析，文本翻译，等等。你可以在官方文档阅读TextBlog的所有特性。</p><p>github 地址：<a href="https://github.com/sloria/TextBlob/" target="_blank" rel="noopener">https://github.com/sloria/TextBlob/</a></p><p>文档地址：<a href="https://textblob.readthedocs.io/en/dev/" target="_blank" rel="noopener">https://textblob.readthedocs.io/en/dev/</a><br>TextBlob是在NLTK和pattern基础上构建的，并且与这两者完美契合。</p><h2 id="安装-TextBlob"><a href="#安装-TextBlob" class="headerlink" title="安装 TextBlob"></a>安装 TextBlob</h2><pre><code>$ pip install -U textblob$ python -m textblob.download_corpora # 下载nltk数据包，如果已经在nltk 安装的时候下载好了nltk数据包，不需要此步骤</code></pre><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>Create a TextBlob（创建一个textblob对象）</p><pre><code>from textblob import TextBlobwiki = TextBlob(&quot;Python is a high-level, general-purpose programming language.&quot;)</code></pre><p>Part-of-speech Tagging（词性标注）</p><pre><code>wiki.tags[(&apos;Python&apos;, &apos;NNP&apos;), (&apos;is&apos;, &apos;VBZ&apos;), (&apos;a&apos;, &apos;DT&apos;), (&apos;high-level&apos;, &apos;JJ&apos;), (&apos;general-purpose&apos;, &apos;JJ&apos;), (&apos;programming&apos;, &apos;NN&apos;), (&apos;language&apos;, &apos;NN&apos;)]</code></pre><p>Sentiment Analysis（情感分析）</p><pre><code>testimonial = TextBlob(&quot;Textblob is amazingly simple to use. What great fun!&quot;)testimonial.sentimentSentiment(polarity=0.39166666666666666, subjectivity=0.4357142857142857)testimonial.sentiment.polarity0.39166666666666666</code></pre><p>Tokenization（分词和分句）</p><pre><code>zen = TextBlob(&quot;Beautiful is better than ugly. &quot;...                &quot;Explicit is better than implicit. &quot;...                &quot;Simple is better than complex.&quot;)zen.wordsWordList([&apos;Beautiful&apos;, &apos;is&apos;, &apos;better&apos;, &apos;than&apos;, &apos;ugly&apos;, &apos;Explicit&apos;, &apos;is&apos;, &apos;better&apos;, &apos;than&apos;, &apos;implicit&apos;, &apos;Simple&apos;, &apos;is&apos;, &apos;better&apos;, &apos;than&apos;, &apos;complex&apos;])zen.sentences[Sentence(&quot;Beautiful is better than ugly.&quot;), Sentence(&quot;Explicit is better than implicit.&quot;), Sentence(&quot;Simple is better than complex.&quot;)]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自然语言处理-textblog-安装使用&quot;&gt;&lt;a href=&quot;#自然语言处理-textblog-安装使用&quot; class=&quot;headerlink&quot; title=&quot;自然语言处理 textblog 安装使用&quot;&gt;&lt;/a&gt;自然语言处理 textblog 安装使用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="自然语言处理(NLP)" scheme="https://yuzhen-li.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP/"/>
    
      <category term="textblog" scheme="https://yuzhen-li.github.io/tags/textblog/"/>
    
  </entry>
  
  <entry>
    <title>docker（一）</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/docker%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/docker（一）/</id>
    <published>2018-04-15T15:23:12.000Z</published>
    <updated>2018-05-10T07:50:45.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装docker-for-ubuntu"><a href="#安装docker-for-ubuntu" class="headerlink" title="安装docker for ubuntu"></a>安装docker for ubuntu</h2><p>从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="comment">[选项]</span> <span class="comment">[Docker Registry 地址<span class="comment">[:端口号]</span>/]</span>仓库名<span class="comment">[:标签]</span></span><br></pre></td></tr></table></figure></p><p>具体的选项可以通过 docker pull –help 命令看到,这里我们说一下镜像 名 称 的 格 式。Docker 镜像仓库地址：地址的格式一般是&lt;域名/IP&gt;[:端口号]。默认地址是Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。 对于 DockerHub，如果不给出用户名，则默认为librar，也就是官方镜像。<br>比如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull <span class="string">ubuntu:</span><span class="number">16.04</span></span><br><span class="line"><span class="number">16.04</span>: Pulling from library/ubuntu</span><br><span class="line"><span class="string">bf5d46315322:</span> Pull complete</span><br><span class="line"><span class="number">9</span><span class="string">f13e0ac480c:</span> Pull complete</span><br><span class="line"><span class="string">e8988b5b3097:</span> Pull complete</span><br><span class="line"><span class="number">40</span><span class="string">af181810e7:</span> Pull complete</span><br><span class="line"><span class="string">e6f7c7e5c03e:</span> Pull complete</span><br><span class="line"><span class="string">Digest:</span> <span class="string">sha256:</span><span class="number">147913621</span>d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span><span class="number">16.04</span></span><br></pre></td></tr></table></figure></p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 docker image ls或者docker images 命令。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              c9d990395902        <span class="number">2</span> weeks ago         <span class="number">113</span>MB</span><br><span class="line">cita/cita-run       latest              <span class="number">14</span>f6fa0d1610        <span class="number">3</span> weeks ago         <span class="number">530</span>MB</span><br><span class="line">cita/cita-build     latest              <span class="number">3</span>ea9fdb515e6        <span class="number">4</span> weeks ago         <span class="number">1.47</span>GB</span><br></pre></td></tr></table></figure><p>镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。</p><h2 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h2><p>你可以通过以下命令来便捷的查看<strong>镜像、容器、数据卷</strong>所占用的空间<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> system </span>df</span><br><span class="line">TYPE TOTAL ACTIVE SIZE RECLAI</span><br><span class="line">MABLE</span><br><span class="line">Images 24 0 1.992GB 1.992G</span><br><span class="line">B (100%)</span><br><span class="line">Containers 1 0 62.82MB 62.82M</span><br><span class="line">B (100%)</span><br><span class="line">Local Volumes 9 0 652.2MB 652.2M</span><br><span class="line">B (100%)</span><br><span class="line">Build Cache 0B 0</span><br></pre></td></tr></table></figure></p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm <span class="string">[选项]</span> &lt;镜像<span class="number">1</span>&gt; <span class="string">[&lt;镜像2&gt; ...]</span></span><br></pre></td></tr></table></figure><p>其中， &lt;镜像&gt; 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者镜像摘要。</p><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> = docker create + docker start</span></span><br></pre></td></tr></table></figure><h2 id="镜像定制"><a href="#镜像定制" class="headerlink" title="镜像定制"></a>镜像定制</h2><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">run</span> <span class="comment">--name webserver -d -p 80:80 nginx</span></span><br></pre></td></tr></table></figure></p><p>这条命令会用 nginx 镜像启动一个容器，命名为 webserver ，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost；如果使用的是" target="_blank" rel="noopener">http://localhost；如果使用的是</a> Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用docker exec 命令进入容器，修改其内容。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker exec -it webserver bash</span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># exit</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>我们以交互式终端方式进入webserver容器，并执行了bash命令，也就是获得一个可操作的 Shell。然后，我们用 </p><h1>Hello, Docker!</h1> 覆盖了 /usr/share/nginx/html/index.html的内容。现在我们再刷新浏览器的话，会发现内容被改变了.<p></p><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。<br>而 Docker 提供了一个docker commit命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; <span class="meta">[&lt;仓库名&gt;[:&lt;标签&gt;]</span>]</span><br></pre></td></tr></table></figure></p><p>我们可以用下面的命令将容器保存为镜像：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">-<span class="ruby">-author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</span></span><br><span class="line"><span class="ruby">--message <span class="string">"修改了默认网页"</span> \</span></span><br><span class="line"><span class="ruby">webserver \</span></span><br><span class="line"><span class="ruby"><span class="symbol">nginx:</span>v2</span></span><br><span class="line"><span class="ruby"><span class="symbol">sha256:</span><span class="number">07</span>e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span></span><br></pre></td></tr></table></figure></p><p>其中 –author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git<br>版本控制相似，不过这里这些信息可以省略留空。<br>我们可以在 docker image ls 中看到这个新定制的镜像.</p><h2 id="Dockerfile-镜像定制"><a href="#Dockerfile-镜像定制" class="headerlink" title="Dockerfile 镜像定制"></a>Dockerfile 镜像定制</h2><p>从刚才的 docker commit的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装docker-for-ubuntu&quot;&gt;&lt;a href=&quot;#安装docker-for-ubuntu&quot; class=&quot;headerlink&quot; title=&quot;安装docker for ubuntu&quot;&gt;&lt;/a&gt;安装docker for ubuntu&lt;/h2&gt;&lt;p&gt;从 
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="docker" scheme="https://yuzhen-li.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>诗和远方1</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B91/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/诗和远方1/</id>
    <published>2018-04-15T13:31:50.000Z</published>
    <updated>2018-04-15T13:32:35.383Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="散文随笔" scheme="https://yuzhen-li.github.io/categories/%E6%95%A3%E6%96%87%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>诗和远方</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/诗和远方/</id>
    <published>2018-04-15T13:17:33.000Z</published>
    <updated>2018-04-15T13:18:11.006Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="散文随笔" scheme="https://yuzhen-li.github.io/categories/%E6%95%A3%E6%96%87%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Stanford_CoreNLP在Ubuntu下的安装与使用</title>
    <link href="https://yuzhen-li.github.io/2018/04/15/Stanford-CoreNLP%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://yuzhen-li.github.io/2018/04/15/Stanford-CoreNLP在Ubuntu下的安装与使用/</id>
    <published>2018-04-15T12:22:48.000Z</published>
    <updated>2018-04-15T15:54:27.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stanford-CoreNLP安装以及使用"><a href="#stanford-CoreNLP安装以及使用" class="headerlink" title="stanford CoreNLP安装以及使用"></a>stanford CoreNLP安装以及使用</h1><p>stanford CoreNLP快搞死我了，查了不少资料花费了接近3个小时，才安装完成，并且学会使用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Stanford CoreNLP提供了一系列自然语言分析工具。它能够给出基本的词形，词性，不管是公司名还是人名等，格式化的日期，时间，量词，并且能够标记句子的结构，语法形式和字词依赖，指明那些名字指向同样的实体，指明情绪，提取发言中的开放关系等。如果需要进行如下任务，Standfrod CoreNLP正合适：</p><pre><code>1一个集成的语言分析工具集；2进行快速，可靠的任意文本分析；3.整体的高质量的文本分析;4.支持多种主流语言;5.多种编程语言的易用接口;6.方便的简单的部署web服务。</code></pre><p>Stanford CoreNLP是一个集成的框架。框架的目标是使得应用一大堆语言分析工具分析大量的文本变得简单。COreNLP工具可以仅仅通过两行命令执行大量的文本分析工作。框架设计的初衷就是高度灵活的可扩展性的。通过一个单独的名利ing就可以选择某个工具的开启和关闭。Stanford CoreNLP集成了许多斯坦福的NLP工具，包括：词性标记（POS），命名实体识别（NER），语法，参数分析系统，情绪分析，自举模式学习，和开放信息提取工具。这个框架的分析为高等级和指定领域的文本理解应用程序提供了基本的构件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要安装Java运行环境，以Ubuntu 12.04为例，安装Java运行环境仅需要两步：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> <span class="keyword">default</span>-jre</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">default</span>-jdk</span><br></pre></td></tr></table></figure></p><p>然后下载Stanford coreNLP 包：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://nlp.stanford.edu/software/stanford-corenlp-full<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>.zip</span><br><span class="line"></span><br><span class="line">unzip stanford-corenlp-full<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>.zip</span><br><span class="line"></span><br><span class="line">cd stanford-corenlp-full<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>/</span><br></pre></td></tr></table></figure></p><p>配置环境变量：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `<span class="builtin-name">find</span> . -name <span class="string">"*.jar"</span>`; <span class="keyword">do</span> <span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=<span class="string">"<span class="variable">$CLASSPATH</span>:`realpath <span class="variable">$file</span>`"</span>; done</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `<span class="builtin-name">find</span> /path/<span class="keyword">to</span>/corenlp/ -name <span class="string">"*.jar"</span>`; <span class="keyword">do</span> <span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=<span class="string">"<span class="variable">$CLASSPATH</span>:`realpath <span class="variable">$file</span>`"</span>; done</span><br></pre></td></tr></table></figure><p>安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 <span class="keyword">install</span> stanfordcorenlp</span><br></pre></td></tr></table></figure></p><p>处理中文还需要下载中文的模型jar文件，然后放到stanford-corenlp-full-2018-02-27根目录下即可<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nlp.stanford.edu/software/stanford-chinese-corenlp<span class="string">-2018</span><span class="string">-02</span><span class="string">-27</span>-models.jar</span><br></pre></td></tr></table></figure></p><h2 id="中文使用方法"><a href="#中文使用方法" class="headerlink" title="中文使用方法"></a>中文使用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"></span><br><span class="line">nlp = StanfordCoreNLP(<span class="string">r'/mnt/f/CMBNLP/stanford-corenlp-full-2018-02-27/'</span>, lang=<span class="string">'zh'</span>) <span class="comment">## 这里是coreNLP的路径</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'清华大学位于北京。'</span></span><br><span class="line"><span class="keyword">print</span> nlp.word_tokenize(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.pos_tag(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.ner(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.parse(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.dependency_parse(sentence)</span><br></pre></td></tr></table></figure><h2 id="英文使用方法"><a href="#英文使用方法" class="headerlink" title="英文使用方法"></a>英文使用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"></span><br><span class="line">nlp = StanfordCoreNLP(<span class="string">r'/mnt/f/CMBNLP/stanford-corenlp-full-2018-02-27/'</span>) <span class="comment">## 这里是coreNLP的路径,与中文相比，省略了, lang='zh'</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'You are a beautiful girl1'</span></span><br><span class="line"><span class="keyword">print</span> nlp.word_tokenize(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.pos_tag(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.ner(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.parse(sentence)</span><br><span class="line"><span class="keyword">print</span> nlp.dependency_parse(sentence)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stanford-CoreNLP安装以及使用&quot;&gt;&lt;a href=&quot;#stanford-CoreNLP安装以及使用&quot; class=&quot;headerlink&quot; title=&quot;stanford CoreNLP安装以及使用&quot;&gt;&lt;/a&gt;stanford CoreNLP安装以及
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yuzhen-li.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="NLP" scheme="https://yuzhen-li.github.io/tags/NLP/"/>
    
      <category term="stanford" scheme="https://yuzhen-li.github.io/tags/stanford/"/>
    
      <category term="CoreNLP" scheme="https://yuzhen-li.github.io/tags/CoreNLP/"/>
    
  </entry>
  
</feed>
